{"meta":{"title":"Ther's Blog","subtitle":"学习笔记","description":"分享学习与生活","author":"Ther","url":"https://www.niuwx.cn","root":"/"},"pages":[{"title":"","date":"2021-07-01T04:38:52.348Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"404.html","permalink":"https://www.niuwx.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-07-01T04:38:52.348Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"about/index.html","permalink":"https://www.niuwx.cn/about/index.html","excerpt":"","text":"感谢你的访问，这个博客将记录我各种瞎折腾和一丢丢的学习笔记，如果你也有相同的兴趣和爱好，欢迎一起交流！ 博客升级记录 2021-3-18 增加友链和开往功能解决了在部署过程中出现TYPE ERROR的问题 2021-3-17 增加了评论系统的邮箱提醒功能 2021-2-29 绑定自定义域名 + 腾讯CDN加速、实现HTTPS，访问速度快的一批 2021-2-15 修改评论系统 2021-2-11 Github page + Hexo + Volantis 成功搭建博客"},{"title":"所有分类","date":"2021-07-01T04:38:52.348Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"categories/index.html","permalink":"https://www.niuwx.cn/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-07-01T04:38:52.348Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"friends/index.html","permalink":"https://www.niuwx.cn/friends/index.html","excerpt":"互联网将人与人之间的距离大大减小，却还是形成了大大小小的孤岛。只有熟人间才知道彼此，而陌生人永远只能是陌生人。 我们不必互相了解彼此，简单的互换友链，只需要一个徽标，占用一块位置，我们所有人都联系在了一起，简单而又强大。大大小小的孤岛散落在浩瀚烟海，开往就像是一颗颗星球之间的快速列车，随机的跳转下一站。 欢迎交换友联，请在评论区留言","text":"互联网将人与人之间的距离大大减小，却还是形成了大大小小的孤岛。只有熟人间才知道彼此，而陌生人永远只能是陌生人。 我们不必互相了解彼此，简单的互换友链，只需要一个徽标，占用一块位置，我们所有人都联系在了一起，简单而又强大。大大小小的孤岛散落在浩瀚烟海，开往就像是一颗颗星球之间的快速列车，随机的跳转下一站。 欢迎交换友联，请在评论区留言 格式本站信息123456- title: # 名称 avatar: # 头像 url: # 链接 screenshot: # 截图 keywords: # 关键词 description: # 描述123456- title: Fadai avatar: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;28251536&#x2F;cloudimg@master&#x2F;img%E5%A4%B4%E5%83%8F.png url: https:&#x2F;&#x2F;www.niuwx.cn screenshot: #截图 keywords: 马无夜草不肥，人无横财不富。 description: 蒟蒻的学习笔记"},{"title":"所有标签","date":"2021-07-01T04:38:52.348Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"tags/index.html","permalink":"https://www.niuwx.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"拓展欧几里得","slug":"拓展欧几里得","date":"2021-04-27T11:20:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"拓展欧几里得/","link":"","permalink":"https://www.niuwx.cn/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"","text":"欧几里得算法欧几里得算法又称辗转相除法，用于求两个数的最大公因数，代码如下： 123int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b,a%b);&#125; 例如：当a = 75， b = 48 时，过程如下， 拓展欧几里得这种算法，它可以在辗转相除途中求出不定方程 $ax+by=c$的一组解。 在上图中，倒数第二行的等式$3+6\\ast3=21$可以移项写为$3=6\\ast(-3)+21$，此时3可以表示为6和21的线性组合。 倒数第三行6的线性组合$6=21\\ast(-1)+27$，则3又可以被表示为$3=(21\\ast(-1)+27)\\ast(-3)+21=27\\ast(-3)+21\\ast4$ … 以此类推，则3可以表示为75和48的线性组合，就可以找到$75x+48y=3$的解了。 3是75和48的最大公因数，经过上面的步骤可得求$ax+by=c(c == gcd(a,b))$的解，如果c是其他的数还可以用这个方法吗，实际上，c必须是gcd(a,b)的倍数，如下： $ax+by=c$两边同时除以gcd(a,b)得$\\frac{ax}{gcd(a,b)}+\\frac{by}{gcd(a,b)}=\\frac {c}{gcd(a,b)}$，方程左边都为整数，则c为gcd(a,b)的倍数才能使得方程成立。 算法代码如下： 1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int x0 = x; int y0 = y; x = y0; y = x0 - (a / b) * y0; return d;&#125; 简洁写法如下： 12345678910int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); //这里交换了x,y; y -= (a / b) * x;&#125; 这样就得到了一组特解，如何求通解呢？ 设除了特解之外还有一组解$x_1=x+t、y_1$，那么由$ax_1-at+by=gcd(a,b)$得$ax_1+b(y-\\frac{a}{b}t)=gcd(a,b)$，可得，$y_1=y-\\frac{a}{b}t$。 这里必须保证$t$和$\\frac{a}{b}t$都是整数，设后者等于$\\frac{a’}{b’}t$，$a’=\\frac{a}{gcd(a,b)},b’=\\frac{b}{gcd(a,b)}$。由于$a’$与$b’$互质，$t$应当为$kb’(k\\in Z)$， 即： $${\\begin{matrix}x_k = x+k\\frac{b}{gcd(a,b)}\\y_k = y-k\\frac{a}{gcd(a,b)}\\(k\\in Z)\\\\end{matrix}$$ 这便是该不定方程的通解 例题题目描述求关于$x$的同余方程 $ax \\equiv 1 \\pmod {b}$的最小正整数解。输入格式一行，包含两个正整数 $a,b$用一个空格隔开。输出格式一个正整数 $x_0$ ，即最小正整数解。输入数据保证一定有解。 $ax \\equiv 1 \\pmod {b}$等价于$ax-1=yb$，即$ax-by=1$，由于$y$可以是负数，改写为$ax+by=1$，至此，可以使用拓展欧几里得进行求解。由于有解条件为$gcd(a,b)=1$，即a，b互质，则通解$x_k=x+kb$。题目需求x的最小正整数解，对$x+b$取$b$的模即可。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int x0 = x, y0 = y; x = y0; y = x0 - (a / b) * y0; return d;&#125;int main() &#123; int a, b; int x, y; cin &gt;&gt; a &gt;&gt; b; exgcd(a, b, x, y); cout &lt;&lt; (x + b) % b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"拓展欧几里得","slug":"拓展欧几里得","permalink":"https://www.niuwx.cn/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2021-03-27T11:20:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"拓扑排序/","link":"","permalink":"https://www.niuwx.cn/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"这篇文章将介绍图论中的拓扑排序。","text":"这篇文章将介绍图论中的拓扑排序。 什么是拓扑排序？对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。 拓扑排序 入度：指向v的边的个数叫做v的入度。 出度：v指向的点的个数叫做v的出度。 如果一个点的入度是0，那么说明这个点是起点（起点不止一个）。如果一个点的出度为0，那么说明这个点排在最后。 举例说明： 如图所示，这是一个有向无环图，其指向顺序为a,(b,c),d,e,则abcde和acbde都是这个图的拓扑排序。 很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。 拓扑排序的实现DFS和BFS都可以实现拓扑排序。 BFS实现拓扑排序这种算法也叫做Kahn算法 继续使用上面的例子进行说明 BFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。 无前驱的顶点优先就是顺着找，a的入度为0，则其为起点，a入队； a出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队； 目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队； b出队，b指向d，d入度减一，d入度为零，入队； d出队，d指向e，e入度减一，e入度为零，入队； e出队，无后续结点，结束。 由上述过程可得拓扑排序为acbde。 时间复杂度假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。 代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int T, n, m, u, v;int deg[N];int vis[N];int dest[N];vector&lt;int&gt; g[N];queue&lt;int&gt; q;bool toposort() &#123; //将入度为零的点放入队列 for (int i = 1; i &lt;= n; i++) &#123; if (!deg[i]) &#123; vis[i] = 1; q.push(i); &#125; &#125; int num = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); dest[num++] = now; for (auto to : g[now]) &#123; if (vis[to]) //判断该节点是否在队列中 continue; else &#123; deg[to]--; //入度减一 if (!deg[to]) &#123; //判断入度是否为零 q.push(to); //入队 vis[to] = 1; //标记其在队列中 &#125; &#125; &#125; &#125; if (num == n) return true; else return false;&#125;int main(int argc, char const *argv[]) &#123; memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); memset(dest, 0, sizeof(dest)); for (int i = 1; i &lt;= N; i++) g[i].clear(); while (!q.empty()) q.pop(); //以上为初始化 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); //读入 g[u].push_back(v); deg[v]++; //统计入度 &#125; if (toposort()) &#123;//如果可以生成拓扑排序 for (int i = 0; i &lt; n; i++) //输出结果 printf(&quot;%d%c&quot;, dest[i], i == n ? &#x27;\\n&#x27; : &#x27; &#x27;); &#125; else printf(&quot;NO\\n&quot;); return 0;&#125; 123456789101112//测试数据//有向有环图2 11 33 44 2//有向无环图1 21 33 42 44 5 DFS实现拓扑排序12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int n, u, v;int c[N]; // 标志数组vector&lt;int&gt; G[N]; // vector 实现的邻接表vector&lt;int&gt; topo; // 拓扑排序后的节点bool dfs(int u) &#123; c[u] = -1; for (int v : G[u]) &#123; if (c[v] &lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; &#125; c[u] = 1; topo.push_back(u); return true;&#125;bool toposort() &#123; topo.clear(); memset(c, 0, sizeof(c)); for (int u = 0; u &lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true;&#125;int main(int argc, char const *argv[]) &#123; return 0;&#125;","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://www.niuwx.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"图论","slug":"图论","permalink":"https://www.niuwx.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Go语言基础之并发","slug":"Go语言基础之并发","date":"2021-03-24T13:20:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之并发/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/","excerpt":"并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。","text":"并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。 并发和并行并发：同一时间段内执行多个任务。 并行：同一时刻执行多个任务。 Go语言的并发通过goroutine实现。goroutine类似于进程，属于用户态的进程。可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时调度完成，而线程是由操作系统调度完成。 Go语言还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言并成的CSP并发模式的重要实现基础。 goroutineGo语言中goroutine的概念类似于线程但 goroutine是由Go的运行时（runtime）调度和管理的。 goroutine的使用Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加go关键字，就可以为一个函数创建一个goroutine。 一个gotoutine必定对应一个函数，可以创建的多个goroutine去执行相同的函数。 启动单个goroutine例如： 1234567891011package mainimport &quot;fmt&quot;func hello() &#123; fmt.Println(&quot;Hello goroutine!&quot;)&#125;func main() &#123; hello() fmt.Println(&quot;main goroutine done!&quot;)&#125; 这个例子的输出结果是Hello goroutine! 和main goroutine done!。 1234567891011package mainimport &quot;fmt&quot;func hello() &#123; fmt.Println(&quot;Hello goroutine!&quot;)&#125;func main() &#123; go hello() fmt.Println(&quot;main goroutine done!&quot;)&#125; 这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了main goroutine done!，这是为什么呢？ 在程序启动时，Go程序为main()函数创建一个默认的goroutine，当main()函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，hello()还没来得及进行，程序就结束了。 如何才能将hello()进行呢？最简单粗暴的方式就是time.Sleep。 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;time&quot;)func hello() &#123; fmt.Println(&quot;Hello goroutine!&quot;)&#125;func main() &#123; go hello() fmt.Println(&quot;main goroutine done!&quot;) time.Sleep(1000)&#125; 执行上面的代码会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。 启动多个goroutine例子： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc hello(i int) &#123; defer wg.Done() //goroutine结束也要登记,-1 fmt.Println(&quot;Hello goroutine&quot;, i)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; wg.Add(1) //启动一个goroutine就登记一次,+1 go hello(i) &#125; wg.Wait() //等待所有登记的goroutine都结束&#125; 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。 goroutine与线程goroutine调度GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。 GOMAXPROCSGo运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。 Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。 Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。 我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如： 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;time&quot;)func a() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;A:&quot;, i) &#125;&#125;func b() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;B:&quot;, i) &#125;&#125;func main() &#123; runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second)&#125; 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。 Go语言中的操作系统线程和goroutine的关系： 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。 channel单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 channel类型channel是一种类型，一种引用类型。声明格式如下： 1var 变量 chan 元素类型 例如： 123var ch1 chan intvar ch2 chan boolvar ch3 chan []int 创建channel通道是引用类型，通道类型的空值是nil。 12var ch chan intfmt.Println(ch) //nil 声明的通道在make初始化后才能使用。 格式如下： 1make(chan 元素类型, [大小]) 例如： 123ch1 := make(chan int)ch2 := make(chan bool)ch3 := make(chan []int) channel操作通道有发送（send）、接收(receive）和关闭（close）三种操作。 发送和接收都使用&lt;-符号。 现在我们先使用以下语句定义一个通道： 1ch := make(chan int) 发送将一个值发送到通道中。 1ch &lt;- 10 // 把10发送到ch中 接收从一个通道中接收值。 12x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch // 从ch中接收值，忽略结果 关闭我们通过调用内置的close函数来关闭通道。 1close(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 关闭后的通道有以下特点： 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。 无缓冲的通道无缓冲的通道又称为阻塞的通道。例如： 1234567891011package mainimport ( &quot;fmt&quot;)func main() &#123; ch := make(chan int) ch &lt;- 10 fmt.Println(&quot;成功&quot;)&#125; 这段代码在执行时会出现错误 123456fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main() E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5fexit status 2 因为ch := make(chan int)创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。 上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁。 解决方法： 一种方法就是启用一个goroutine去接受，例如： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func rec(c chan int) &#123; ret := &lt;-c fmt.Println(&quot;成功&quot;, ret)&#125;func main() &#123; ch := make(chan int) go rec(ch) ch &lt;- 10 fmt.Println(&quot;成功&quot;)&#125; 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。 有缓冲的通道解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如： 12345func main() &#123; ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch &lt;- 10 fmt.Println(&quot;发送成功&quot;)&#125; 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。 我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量。 for range 从通道循环取值当向通道中发送完数据时，我们可以通过close函数来关闭通道。 当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？ 看这个例子： 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;func main() &#123; ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() &#123; for i := 0; i &lt; 100; i++ &#123; ch1 &lt;- i &#125; close(ch1) &#125;() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 go func() &#123; for &#123; i, ok := &lt;-ch1 // 通道关闭后再取值ok=false if !ok &#123; break &#125; ch2 &lt;- i * i &#125; close(ch2) &#125;() // 在主goroutine中从ch2中接收值打印 for i := range ch2 &#123; // 通道关闭后会退出for range循环 fmt.Println(i) &#125;&#125; 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。 单向通道有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。 Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下： 1234567891011121314151617181920212223242526func counter(out chan&lt;- int) &#123; for i := 0; i &lt; 100; i++ &#123; out &lt;- i &#125; close(out)&#125;func squarer(out chan&lt;- int, in &lt;-chan int) &#123; for i := range in &#123; out &lt;- i * i &#125; close(out)&#125;func printer(in &lt;-chan int) &#123; for i := range in &#123; fmt.Println(i) &#125;&#125;func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2)&#125; 其中， chan&lt;- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； &lt;-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。 worker pool （goroutine池）在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。 例如： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;time&quot;)func worker(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for i := range jobs &#123; fmt.Printf(&quot;worker:%d start job:%d\\n&quot;, id, i) time.Sleep(time.Second) fmt.Printf(&quot;worker:%d end job:%d\\n&quot;, id, i) results &lt;- i * 2 &#125;&#125;func main() &#123; jobs := make(chan int, 100) results := make(chan int, 100) //只开启3个goroutine for w := 1; w &lt;= 3; w++ &#123; go worker(w, jobs, results) &#125; //5个任务 for j := 1; j &lt;= 5; j++ &#123; jobs &lt;- j &#125; close(jobs) for a := 1; a &lt;= 5; a++ &#123; &lt;-results &#125;&#125; select多路复用在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现： 1234567for&#123; // 尝试从ch1接收值 data, ok := &lt;-ch1 // 尝试从ch2接收值 data, ok := &lt;-ch2 …&#125; 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。 select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下： 12345678910select&#123; case &lt;-ch1: ... case data := &lt;-ch2: ... case ch3&lt;-data: ... default: 默认操作&#125; 举个例子来演示下select的使用： 12345678910func main() &#123; ch := make(chan int, 1) for i := 0; i &lt; 10; i++ &#123; select &#123; case x := &lt;-ch: fmt.Println(x) case ch &lt;- i: &#125; &#125;&#125; 使用select语句能提高代码的可读性。 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select&#123;&#125;会一直等待，可用于阻塞main函数。 并发安全和锁有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 举个例子： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var x int64var wg sync.WaitGroupfunc add() &#123; for i := 0; i &lt; 50000; i++ &#123; x = x + 1 &#125; wg.Done()&#125;func main() &#123; wg.Add(2) go add() go add() wg.Wait() fmt.Println(x)&#125; 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。 互斥锁互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var x int64var wg sync.WaitGroupvar lock sync.Mutexfunc add() &#123; for i := 0; i &lt; 50000; i++ &#123; lock.Lock() //上锁 x = x + 1 lock.Unlock() //解锁 &#125; wg.Done()&#125;func main() &#123; wg.Add(2) go add() go add() wg.Wait() fmt.Println(x)&#125; 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。 读写互斥锁互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。 读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。 读写锁示例： 123456789101112131415161718192021222324252627282930313233343536373839404142var ( x int64 wg sync.WaitGroup //lock sync.Mutex rwlock sync.RWMutex)func write() &#123; // lock.Lock() // 加互斥锁 rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 // lock.Unlock() // 解互斥锁 wg.Done()&#125;func read() &#123; // lock.Lock() // 加互斥锁 rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 // lock.Unlock() // 解互斥锁 wg.Done()&#125;func main() &#123; start := time.Now() for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go write() &#125; for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go read() &#125; wg.Wait() end := time.Now() fmt.Println(end.Sub(start))&#125; 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。 sync.WaitGroup在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法： 方法名 功能 (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。 我们利用sync.WaitGroup将上面的代码优化一下： 123456789101112var wg sync.WaitGroupfunc hello() &#123; defer wg.Done() fmt.Println(&quot;Hello Goroutine!&quot;)&#125;func main() &#123; wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(&quot;main goroutine done!&quot;) wg.Wait()&#125; 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。 sync.Once说在前面的话：这是一个进阶知识点。 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。 Go语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。 sync.Once只有一个Do方法，其签名如下： 1func (o *Once) Do(f func()) &#123;&#125; 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。 加载配置文件示例延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子： 123456789101112131415161718var icons map[string]image.Imagefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon 被多个goroutine调用时不是并发安全的func Icon(name string) image.Image &#123; if icons == nil &#123; loadIcons() &#125; return icons[name]&#125; 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果： 1234567func loadIcons() &#123; icons = make(map[string]image.Image) icons[&quot;left&quot;] = loadIcon(&quot;left.png&quot;) icons[&quot;up&quot;] = loadIcon(&quot;up.png&quot;) icons[&quot;right&quot;] = loadIcon(&quot;right.png&quot;) icons[&quot;down&quot;] = loadIcon(&quot;down.png&quot;)&#125; 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。 使用sync.Once改造的示例代码如下： 123456789101112131415161718var icons map[string]image.Imagevar loadIconsOnce sync.Oncefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon 是并发安全的func Icon(name string) image.Image &#123; loadIconsOnce.Do(loadIcons) return icons[name]&#125; 并发安全的单例模式下面是借助sync.Once实现的并发安全的单例模式： 1234567891011121314151617package singletonimport ( &quot;sync&quot;)type singleton struct &#123;&#125;var instance *singletonvar once sync.Oncefunc GetInstance() *singleton &#123; once.Do(func() &#123; instance = &amp;singleton&#123;&#125; &#125;) return instance&#125; sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。 sync.MapGo语言中内置的map不是并发安全的。请看下面的示例： 1234567891011121314151617181920212223var m = make(map[string]int)func get(key string) int &#123; return m[key]&#125;func set(key string, value int) &#123; m[key] = value&#125;func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go func(n int) &#123; key := strconv.Itoa(n) set(key, n) fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, get(key)) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。 像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。 12345678910111213141516var m = sync.Map&#123;&#125;func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go func(n int) &#123; key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, value) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 原子操作代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。 示例我们填写一个示例来比较下互斥锁和原子操作的性能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot;)type Counter interface &#123; Inc() Load() int64&#125;// 普通版type CommonCounter struct &#123; counter int64&#125;func (c CommonCounter) Inc() &#123; c.counter++&#125;func (c CommonCounter) Load() int64 &#123; return c.counter&#125;// 互斥锁版type MutexCounter struct &#123; counter int64 lock sync.Mutex&#125;func (m *MutexCounter) Inc() &#123; m.lock.Lock() defer m.lock.Unlock() m.counter++&#125;func (m *MutexCounter) Load() int64 &#123; m.lock.Lock() defer m.lock.Unlock() return m.counter&#125;// 原子操作版type AtomicCounter struct &#123; counter int64&#125;func (a *AtomicCounter) Inc() &#123; atomic.AddInt64(&amp;a.counter, 1)&#125;func (a *AtomicCounter) Load() int64 &#123; return atomic.LoadInt64(&amp;a.counter)&#125;func test(c Counter) &#123; var wg sync.WaitGroup start := time.Now() for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go func() &#123; c.Inc() wg.Done() &#125;() &#125; wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start))&#125;func main() &#123; c1 := CommonCounter&#123;&#125; // 非并发安全 test(c1) c2 := MutexCounter&#123;&#125; // 使用互斥锁实现并发安全 test(&amp;c2) c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高 test(&amp;c3)&#125; atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"并发","slug":"并发","permalink":"https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"goroutine","slug":"goroutine","permalink":"https://www.niuwx.cn/tags/goroutine/"},{"name":"channel","slug":"channel","permalink":"https://www.niuwx.cn/tags/channel/"},{"name":"select","slug":"select","permalink":"https://www.niuwx.cn/tags/select/"},{"name":"原子操作","slug":"原子操作","permalink":"https://www.niuwx.cn/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"},{"name":"并发安全和锁","slug":"并发安全和锁","permalink":"https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/"}]},{"title":"Go语言基础之接口","slug":"Go语言基础之接口","date":"2021-03-21T07:20:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之接口/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/","excerpt":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。","text":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 接口类型在Go语言中接口（interface）是一种类型，一种抽象的类型。 interface是一组method的集合，不关心属性（数据），只关心行为（方法）。 引入1234567891011121314151617package mainimport &quot;fmt&quot;type Cat struct&#123;&#125; //猫func (c Cat) Say() string &#123; return &quot;喵喵喵&quot; &#125;type Dog struct&#123;&#125; //狗func (d Dog) Say() string &#123; return &quot;汪汪汪&quot; &#125;func main() &#123; c := Cat&#123;&#125; fmt.Println(c.Say()) d := Dog&#123;&#125; fmt.Println(d.Say())&#125; 上述代码定义了猫和狗，以及他们叫声的方法，可以发现，main中会有重复的代码，如果再加上其他动物，代码还会重复，那如果把他们都归类成“会叫的动物”来处理呢？ 像这样类似的例子还有很多，例如： 支付宝、微信、银联等在线支付的方式，可以把它们当成支付方式来处理。 计算三角形、正方形、圆形等的周长和面积，可以把他们当成图形来处理 等等…… 而在Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于所有的具体类型，接口是一种抽象的类型。当看到一个接口类型的值时，你不知道它是什么，只知道通过它的方法能做什么。 接口的定义Go语言提倡面向接口编程 每个接口由数个方法组成，格式如下： 12345type 接口类型名 interface&#123; 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 …&#125; 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。 例如： 123type writer interface&#123; Write([]byte) error&#125; 当你看到这个接口类型的值时，并不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。 接口实现的条件一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表 例如： 123456789101112131415type Sayer interface &#123; Say()&#125;type Cat struct&#123;&#125;func (c Cat) Say() &#123; //Cat实现了Sayer接口 fmt.Println(&quot;喵喵喵&quot;) &#125; type Dog struct&#123;&#125;func (d Dog) Say() &#123; //Dog实现了Sayer接口 fmt.Println(&quot;汪汪汪&quot;) &#125; 接口类型的变量实现了接口有什么作用呢？ 接口类型变量能够储存所有实现了该接口的实例。 例如： 123456789101112func main() &#123; var x Sayer c := Cat&#123;&#125; d := Dog&#123;&#125; x = c x.Say() x = d x.Say()&#125; 值接收者和指针接收者实现接口的区别定义一个Mover接口和一个Dog结构体 12345type Mover interface&#123; move()&#125;type Dog struct&#123;&#125; 值接收者实现接口指针接收者实现接口1234567891011121314func (d Dog) move() &#123; fmt.Println(&quot;狗跑了&quot;)&#125;func main() &#123; var x Mover var wangcai = Dog&#123;&#125; x = wangcai x.move() var fugui = &amp;Dog&#123;&#125; x = fugui x.move()&#125; 从上面这段代码不难发现，使用值接收者实现接口之后，不管是Dog结构体还是*Dog结构体指针类型的变量都可以赋值给该接口变量。同样的代码，如果使用指针接受实现接口呢？ 1234567891011121314func (d *Dog) move() &#123; fmt.Println(&quot;狗跑了&quot;)&#125;func main() &#123; var x Mover var wangcai = Dog&#123;&#125; x = wangcai //x不可以接收Dog类型 x.move() var fugui = &amp;Dog&#123;&#125; x = fugui x.move()&#125; 此时实现Mover接口的是*Dog类型，所以不能给x传入Dog类型。 类型与接口的关系一个类型实现多个接口一个类型可以同时实现多个接口，而接口之间批次独立。例如，狗可以叫，也可以跑。就可以分别定义Sayer接口和Mover接口： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Sayer interface &#123; say()&#125;type Mover interface &#123; move()&#125;type Dog struct &#123; name string&#125;func (d Dog) say() &#123; fmt.Printf(&quot;%s说\\n&quot;, d.name)&#125;func (d Dog) move() &#123; fmt.Printf(&quot;%s跑了\\n&quot;, d.name)&#125;func main() &#123; var x Mover var y Sayer var a = Dog&#123;&quot;旺财&quot;&#125; x = a y = a x.move() y.say()&#125; 多个类型实现同一接口Go语言中不同的类型还可以实现同一接口，例如： 12345678910111213141516171819202122232425262728293031323334353637package mainimport &quot;fmt&quot;type Mover interface &#123; move()&#125;type Dog struct &#123; name string&#125;func (d Dog) move() &#123; fmt.Printf(&quot;%s跑了\\n&quot;, d.name)&#125;type Car struct &#123; name string&#125;func (c Car) move() &#123; fmt.Printf(&quot;%s跑了\\n&quot;, c.name)&#125;func main() &#123; var x Mover var d = Dog&#123;&quot;旺财&quot;&#125; var c = Car&#123;&quot;保时捷&quot;&#125; x = d x.move() x = c c.move() //不关心具体是什么，只需调用方法即可&#125; 接口嵌套接口与接口之间可以通过嵌套创造出新的接口 123456789101112131415//Sayer接口type Sayer interface&#123; say()&#125;//Mover接口type Mover interface&#123; move()&#125;//接口嵌套type animal interface&#123; Sayer Mover&#125; 嵌套得到的接口的使用与普通接口一样： 123456789101112131415161718type Cat struct &#123; name string&#125;func (c Cat) say() &#123; fmt.Println(&quot;喵喵喵&quot;)&#125;func (c Cat) move() &#123; fmt.Println(&quot;猫跑了&quot;)&#125;func main() &#123; var x animal x = Cat&#123;name: &quot;臭宝&quot;&#125; x.move() x.say()&#125; 空接口空接口的定义空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。 空接口类型的变量可以存储任意类型的变量。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; var x interface&#123;&#125; s := &quot;Hello&quot; x = s fmt.Printf(&quot;%T %v\\n&quot;, x, x) i := 100 x = i fmt.Printf(&quot;%T %v\\n&quot;, x, x) b := true x = b fmt.Printf(&quot;%T %v\\n&quot;, x, x)&#125; 空接口的应用空接口作为函数的参数空接口作为map的值使用空接口实现可以接受任意类型的函数参数 123func show(a interface&#123;&#125;) &#123; fmt.Printf(&quot;%T %v\\n&quot;, a, a)&#125;使用空接口实现可以保存任意值的字典。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var studentInfo = make(map[string]interface&#123;&#125;) studentInfo[&quot;name&quot;] = &quot;臭宝&quot; studentInfo[&quot;age&quot;] = 18 studentInfo[&quot;married&quot;] = false fmt.Println(studentInfo) //map[age:18 married:false name:臭宝]&#125; 类型断言","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"接口","slug":"接口","permalink":"https://www.niuwx.cn/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"Go语言基础之结构体（二）","slug":"Go语言基础之结构体（二）","date":"2021-03-21T02:13:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之结构体（二）/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。","text":"在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。 构造函数在C++面向对象中，声明一个对象后，可以写一些针对该对象的一些方法，例如构造函数等。Go语言中的结构体没有构造函数，可以自己实现。 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;//构造函数func Student(name string, age int, id string, score int) *student &#123; return &amp;student&#123; //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 name, age, id, score, &#125;&#125;func main() &#123; s := Student(&quot;小学生&quot;, 7, &quot;666&quot;, 60) fmt.Printf(&quot;%#v\\n&quot;, s) //&amp;main.student&#123;name:&quot;小学生&quot;, age:7, id:&quot;666&quot;, score:60&#125;&#125; 方法和接收者Go语言中的方法(Method)是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者(Receiver)。接收者的概念类似于C++中的this。 定义格式如下： 123func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123; 函数体&#125; 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是this之类的命名。例如，student类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。 例如： 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;//构造函数func Student(name string, age int, id string, score int) *student &#123; return &amp;student&#123; //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 name, age, id, score, &#125;&#125;func (s student) study() &#123; fmt.Printf(&quot;我要好好学习！\\n&quot;)&#125;func main() &#123; p := Student(&quot;小学生&quot;, 7, &quot;666&quot;, 60) p.study()&#125; 方法和函数的区别就是函数不属于任何类型，方法只属于特定的类型 指针类型的接收者值类型的接收者何时使用指针类型接收者指针类型的接收者由一个结构的指针组成，由于指针的特性，调用方法时可以修改接收者指针的任何成员变量，在方法结束后，修改依然有效。这种方法类似于C++中使用this。 例如： 123func (s *student) setAge(age int) &#123; s.age = age&#125; 这是一个修改student的age 的方法 调用： 123456func main() &#123; p := Student(&quot;小学生&quot;, 7, &quot;666&quot;, 60) fmt.Println(p.age) //7 p.setAge(18) fmt.Println(p.age) //18&#125;与指针类型的接收者对比，调用方法时，拿到的是值类型接收者的值的拷贝份。在值类型接收者的方法中可以获取接收者的成员值，但修改成员变量指针对这个副本，无法修改接收者变量本身。 例如： 12345678910func (s student) setAge(age int) &#123; s.age = age&#125;func main() &#123; p := Student(&quot;小学生&quot;, 7, &quot;666&quot;, 60) fmt.Println(p.age) //7 p.setAge(18) fmt.Println(p.age) //7&#125; 需要修改接收者的成员值 接收者是比较复杂的结构体，拷贝开销大 任意类型添加方法Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。例如，基于内置的int类型使用type关键字可以定义新的自定义类型，然后为这个自定义类型添加方法。 12345678910111213141516package mainimport &quot;fmt&quot;type MyInt intfunc (m MyInt) SayHello() &#123; fmt.Println(&quot;Hello, I&#x27;m SatHello&quot;) //Hello, I&#x27;m SatHello&#125;func main() &#123; var m MyInt m.SayHello() m = 100 fmt.Printf(&quot;%#v %T\\n&quot;, m, m) //100 main.MyInt&#125; 注意：只可以给本包的类型定义方法 结构体的匿名字段结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段称为匿名字段。 12345678910111213141516package mainimport &quot;fmt&quot;type student struct &#123; string int&#125;func main() &#123; s := &amp;student&#123; &quot;小学生&quot;, 7, &#125; fmt.Printf(&quot;%#v\\n&quot;, s) //&amp;main.student&#123;string:&quot;小学生&quot;, int:7&#125;&#125; 匿名字段的说法并不代表没有字段名，而是默认采用类型名作为字段名。从其定义中不难发现， 由于结构体要求字段名必须唯一，因此一个结构体中一种类型的匿名字段只能有一个。 嵌套结构体一个结构体中可以嵌套包含另一个结构体或结构体指针，例如： 12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;//成绩信息type grade struct &#123; math int chinese int english int&#125;//学生信息type student struct &#123; name string age int mygrade grade //grade //↑可采用匿名字段的方式嵌套&#125;func main() &#123; s := &amp;student&#123; name: &quot;小学生&quot;, age: 7, mygrade: grade&#123; math: 60, chinese: 60, english: 60, &#125;, &#125; fmt.Printf(&quot;%#v\\n&quot;, s) //&amp;main.student&#123;name:&quot;小学生&quot;, age:7, mygrade:main.grade&#123;math:60, chinese:60, english:60&#125;&#125;&#125; 结构体的“继承”Go语言中使用结构体也可以实现C++中面向对象的继承。 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;type Animal struct &#123; name string&#125;func (a Animal) move() &#123; fmt.Printf(&quot;%s会动\\n&quot;, a.name)&#125;type Dog struct &#123; age int *Animal //通过嵌套匿名结构体实现继承&#125;func (d *Dog) wang() &#123; fmt.Printf(&quot;%s汪汪汪的叫\\n&quot;, d.name)&#125;func main() &#123; d := &amp;Dog&#123; age: 4, Animal: &amp;Animal&#123; name: &quot;小明&quot;, &#125;, &#125; d.move() d.wang()&#125; 结构体字段的可见性结构体中字段大写开头表示可公开访问，小写代表私有（仅在定义当前结构体的包中可访问） 区别私有概念","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"结构体","slug":"结构体","permalink":"https://www.niuwx.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"Go语言基础之结构体（一）","slug":"Go语言基础之结构体（一）","date":"2021-03-20T10:13:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之结构体（一）/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。","text":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 自定义类型和类型别名自定义类型类型别名二者区别在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以像C/C++一样使用type关键字来定义自定义类型。 自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如： 12//将MyInt定义为int类型type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性类型别名规定：MyType只是Type的别名，本质上MyType与Type是同一个类型。 1type MyType = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下： 12type byte = uint8type rune = int32自定义类型和类型别名在语法上看似只有一个等号的差别，但其实不然，例如： 12345678910111213//自定义类型type NewInt int//类型别名type MyInt = intfunc main()&#123; var a NewInt var b MyInt fmt.Printf(&quot;%T\\n&quot;, a) //main.NewInt fmt.Printf(&quot;%T&quot;, b) //int&#125; 输出结果显示a的类型是main.NewInt，表示main包下定义的``NewInt类型；b的类型是int`。 MyInt类型在编译完成时，会被替换成int 结构体Go语言中结构体的定义与C/C++中类似。 我们想表达一个事物的全部或部分属性时，这时用单一的基本数据类型无法满足需求，Go语言提供了自定义数据类型，可以封装多个基本数据类型，这就是结构体。 通过struct来定义，同时在Go语言中，也通过struct实现面向对象 结构体的定义使用type和struct关键字来定义结构体，如下： 12345type MyType struct &#123; Name1 Type1 Name2 Type2 ...&#125; MyType：自定义类型的名称，同一个包中不可重复 Name1和Name2：结构体中成员名称，同一结构体中不可重复 Type1和Type2：成员的具体类型 例如，定义一个学生的结构体： 123456type student struct &#123; name string age int id string score int&#125; 这样，使用student结构体就可以很方便在代码中表示和储存信息了 Go语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型 结构体实例化只有结构体实例化后，才会对相应的变量分配内存。结构体实例化与声明内置类型一样，使用var关键字声明变量 1var student1 student 基本实例化匿名结构体指针类型结构体取结构体的地址实例化通过.访问结构体的成员 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;func main() &#123; var stu student //声明结构体变量 //赋值 stu.name = &quot;小学生&quot; stu.age = 7 stu.id = &quot;666&quot; stu.score = 60 fmt.Println(stu)&#125; 输出结果： 1&#123;小学生 7 666 60&#125;在定义一些临时数据结构等场景下，可以使命匿名结构体 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; var user struct &#123; Name string Age int &#125; user.Name = &quot;小学生&quot; user.Age = 7 fmt.Println(user)&#125; 输出结果： 1&#123;小学生 7&#125;Go语言中还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址： 12345678910111213141516171819202122package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;func main() &#123; var s = new(student) fmt.Printf(&quot;%T\\n&quot;, s) fmt.Println(s) s.name = &quot;小学生&quot; //Go语言中支持对结构体指针直接使用.来访问结构体成员 s.age = 7 s.id = &quot;666&quot; s.score = 60 fmt.Println(s)&#125; 输出结果： 123*main.student&amp;&#123; 0 0&#125;&amp;&#123;小学生 7 666 60&#125;使用&amp;对结构体进行取址操作相当于对该结构体进行了依次new实例化操作 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;func main() &#123; s := &amp;student&#123;&#125; fmt.Printf(&quot;%T\\n&quot;, s) fmt.Println(s) s.name = &quot;小学生&quot; s.age = 7 s.id = &quot;666&quot; s.score = 60 fmt.Println(s)&#125; 输出结果： 123*main.student&amp;&#123; 0 0&#125;&amp;&#123;小学生 7 666 60&#125; 结构体初始化没有初始化的结构体，其成员变量都是对应类型的零值 123456789101112131415package mainimport &quot;fmt&quot;type student struct &#123; name string age int id string score int&#125;func main() &#123; var stu student fmt.Printf(&quot;%#v\\n&quot;, stu)&#125; 输出结果： 1main.student&#123;name:&quot;&quot;, age:0, id:&quot;&quot;, score:0&#125; 使用键值对初始化使用值的列表初始化使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值 12345678stu := student&#123; name: &quot;小学生&quot;, age: 7, id: &quot;666&quot;, score: 60,&#125;fmt.Println(stu)//&#123;小学生 7 666 60&#125; 也可以对结构体指针进行键值对初始化： 12345678stu := student&#123; name: &quot;小学生&quot;, age: 7, id: &quot;666&quot;, score: 60,&#125;fmt.Println(stu)//&amp;&#123;小学生 7 666 60&#125; 当某些字段没有初始值时，该字段可以不写。此时，没有指定初始值的字段的值时该字段类型的零值 123456stu := student&#123; name: &quot;小学生&quot;, score: 60,&#125;fmt.Printf(&quot;%#v&quot;, stu)//main.student&#123;name:&quot;小学生&quot;, age:0, id:&quot;&quot;, score:60&#125;初始话结构体时可以简写，也就是初始化时不写键，直接写值即可： 12345678stu := student&#123; &quot;小学生&quot;, 7, &quot;666&quot;, 60,&#125;fmt.Println(stu)//&#123;小学生 7 666 60&#125; 使用这种格式要注意： 必须初始化结构体的所有字段 顺序必须一致 不可与简直初始化混用 结构体内存布局结构体占用一块连续的内存 1234567891011121314151617181920package mainimport &quot;fmt&quot;type test struct &#123; a int8 b int8 c int8 d int8&#125;func main() &#123; n := test&#123; 1, 2, 3, 4, &#125; fmt.Printf(&quot;n.a %p\\n&quot;, &amp;n.a) fmt.Printf(&quot;n.b %p\\n&quot;, &amp;n.b) fmt.Printf(&quot;n.c %p\\n&quot;, &amp;n.c) fmt.Printf(&quot;n.d %p\\n&quot;, &amp;n.d)&#125; 输出结果： 1234n.a 0xc000012090n.b 0xc000012091n.c 0xc000012092n.d 0xc000012093 空结构体空结构体不占用空间 12var t struct&#123;&#125;fmt.Println(unsafe.Sizeof(t)) // 0","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"结构体","slug":"结构体","permalink":"https://www.niuwx.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"Go语言基础之指针","slug":"Go语言基础之指针","date":"2021-03-20T07:56:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之指针/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/","excerpt":"任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。","text":"任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。 Go语言中的指针Go语言中的指针与C/C++中指针有一定的区别，Go语言中的指针不能进行偏移和运算，是安全指针。因此，Go语言中的指针操作比较简单，只需要记住两个符号&amp;（取址）和*（取值） 指针地址和指针类型每个变量在运行都有一个地址，这个地址也就代表变量在内存中的位置。Go语言中使用&amp;对变量进行取地址。例如： 12a := 10 //定义整型变量ap := &amp;10//p为整型类型的指针类型，其中保存的是变量a的地址 在Go语言中，每个值类型都有对应的指针类型。 指针取值在对变量使用&amp;取地址后，可以使用*对接收了地址的指针变量进行取值，有一个很简单的例子： 123456789package mainimport &quot;fmt&quot;func main() &#123; a := 10 b := &amp;a fmt.Println(*b)&#125; 输出结果 110 指针传值示例12345678910111213package mainimport &quot;fmt&quot;func myfunc(x *int) &#123; *x = 20&#125;func main() &#123; a := 10 myfunc(&amp;a) fmt.Println(a)&#125; 输出结果 120 new &amp; make先分析一个经典的例子 123456789func main() &#123; var a *int *a = 100 fmt.Println(*a) var b map[string]int b[&quot;哈哈哈&quot;] = 100 fmt.Println(b)&#125; 执行这段代码，其实是会报错的。 在声明了整型的指针类型a之后，系统并没有给变量分配内存空间 在声明了map类型的b之后，同样，系统并没有给其分配内存空间 Go语言中对于值类型的声明，在声明的时候就默认分配了内存空间。然而对于引用类型，在使用的时候不仅要声明它，还要给它分配内存空间，否则无法储存。 所以就要使用Go语言中new和make来分配内存 newnew是一个内置的函数，语法如下： 123name := new(Type)//name 变量名//Type 指针变量指向的变量的类型 举例说明： 123456789101112package mainimport &quot;fmt&quot;func main() &#123; a := new(int) b := new(bool) //使用new函数后得到的是一个指针变量，且该指针对应的值为该类型的零值 fmt.Println(*a) fmt.Println(*b)&#125; 在上述开始的经典例子中，var a *int只是声明了指针变量a，但是并未初始化，指针作为引用类型需要初始化才会有内存空间，才可对其进行赋值。 123456func main()&#123; var a *int a = new(int) *a = 100 fmt.Println(*a)&#125; makemake也用于内存分配，区别于new，只用于slice(切片)，map以及chan(通道)的内存创建，而不是他们的指针类型，因为这三种类型本来就是引用类型。 语法如下： 1b := make(map[Type1]Type2, Size) make函数是无可替代的，在使用slice，map以及chan时，都需要使用make初始化。 在上述开始的经典例子中，var b map[string]int只是声明了b是一个map类型的变量，并未初始化。 123456func main()&#123; var b map[string]int b = make(map[string]int, 10) b[&quot;哈哈哈&quot;] = 10 fmt.Println(b)&#125; new和make的异同 new和make都是用来做内存分配的 make只用于slice，map，channel的初始化 new用于指针类型的分配，而且内存对应的值为类型零值","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"指针","slug":"指针","permalink":"https://www.niuwx.cn/tags/%E6%8C%87%E9%92%88/"}]},{"title":"高精度计算","slug":"高精度","date":"2021-03-19T14:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"高精度/","link":"","permalink":"https://www.niuwx.cn/%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题","text":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题 存储高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出 头文件及全局变量1234#include &lt;bits/stdc++.h&gt;static const int LEN = 1004;int a[LEN], b[LEN], c[LEN], d[LEN];int flag; 清空1234void clean(int temp[]) &#123; for (int i = 0; i &lt; LEN; ++i) temp[i] = 0;&#125; 存储1234567891011void read(int temp[]) &#123; static char s[LEN + 1]; scanf(&quot;%s&quot;, s); clean(temp); int len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; temp[len - 1 - i] = s[i] - &#x27;0&#x27;; &#125;&#125; 输出123456789void print(int a[]) &#123; int i; for (i = LEN - 1; i &gt;= 1; --i) if (a[i] != 0) break; for (; i &gt;= 0; i--) putchar(a[i] + &#x27;0&#x27;); putchar(&#x27;\\n&#x27;);&#125; 这样就完成了对于数据的存储与输出 加法高精度加法其实就是按照竖式加法法则来计算 从低位开始相加，满十则向高一位进一，本位取余 这里使用十进制，也可以使用其他更大的进制，如1000进制 1234567891011//高精度加法void add(int a[], int b[], int c[]) &#123; clean(c); for (int i = 0; i &lt; LEN - 1; i++) &#123; c[i] = a[i] + b[i]; if (c[i] &gt; 9) &#123;//判断是否满十 c[i] -= 10; c[i + 1] += 1; &#125; &#125;&#125; 减法高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。 因为要考虑到小数减大数的情况，所以用此函数来判断 1234567891011121314151617181920212223242526bool compare(int a[], int b[]) &#123; int i, j; for (i = LEN - 1; i &gt;= 1; --i) if (a[i] != 0) break; for (j = LEN - 1; j &gt;= 1; --j) if (b[j] != 0) break; if (i &gt; j) &#123; return 0; &#125; else if (i &lt; j) &#123; return 1; &#125; else &#123; for (int p = i; p &gt;= 0; --p) &#123; if (a[p] == b[p]) continue; if (a[p] &gt; b[p]) return 0; else return 1; &#125; &#125; return 0;&#125; 12345678910111213141516171819//高精度减法void sub(int* a, int* b, int* c) &#123; flag = compare(a, b);//判断是否是小数减大数 if (flag) &#123;//如果是 putchar(&#x27;-&#x27;);//则输出负号 sub(b, a, c);//按照大数减小数计算 flag = 0; return; &#125; clean(c); for (int i = 0; i &lt; LEN - 1; i++) &#123; c[i] += a[i] - b[i]; if (c[i] &lt; 0) &#123; c[i] += 10; c[i + 1] -= 1; &#125; &#125;&#125; 乘法高精度*低精度如果是高精度与低精度相乘的话，就没必要使用高精度乘法 123456789101112void mul(int a[], int b, int c[]) &#123; clean(c); for (int i = 0; i &lt; LEN - 1; ++i) &#123; c[i] += a[i] * b;//每位都乘低精度 if (c[i] &gt; 9) &#123; c[i + 1] += c[i] / 10; c[i] %= 10; &#125; &#125;&#125; 高精度*高精度高精度与高精度相乘也是模拟了手写计算乘法的方式 123456789101112131415//高精度乘法void mul(int a[], int b[], int c[]) &#123; clean(c); for (int i = 0; i &lt; LEN - 1; i++) &#123; // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和 for (int j = 0; j &lt;= i; j++) &#123; c[i] += a[j] * b[i - j]; &#125; if (c[i] &gt; 9) &#123; c[i + 1] = c[i] / 10; c[i] %= 10; &#125; &#125;&#125; 除法123456789101112//判断长度inline bool greater_eq(int a[], int b[], int last_dg, int len) &#123; if (a[last_dg + len] != 0) return true; for (int i = len - 1; i &gt;= 0; --i) &#123; if (a[last_dg + i] &gt; b[i]) return true; if (a[last_dg + i] &lt; b[i]) return false; &#125; return true;&#125; 12345678910111213141516171819202122232425262728293031//高精度除法void div(int a[], int b[], int c[], int d[]) &#123; clean(c); clean(d); int la, lb; for (la = LEN - 1; la &gt; 0; --la) if (a[la - 1] != 0) break; for (lb = LEN - 1; lb &gt; 0; --lb) if (b[lb - 1] != 0) break; if (lb == 0) &#123; puts(&quot;除数为零，错误&quot;); return; &#125; for (int i = 0; i &lt; la; ++i) d[i] = a[i]; for (int i = la - lb; i &gt;= 0; --i) &#123; while (greater_eq(d, b, i, lb)) &#123; for (int j = 0; j &lt; lb; ++j) &#123; d[i + j] -= b[j]; if (d[i + j] &lt; 0) &#123; d[i + j + 1] -= 1; d[i + j] += 10; &#125; &#125; c[i] += 1; &#125; &#125;&#125; 测试12345678910111213141516171819int main() &#123; flag = 0; read(a); read(b); add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, b, c); print(c); div(a, b, c, d); print(c); print(d); return 0;&#125;","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"高精度计算","slug":"高精度计算","permalink":"https://www.niuwx.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"Go语言基础之函数","slug":"Go语言基础之函数","date":"2021-03-18T07:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之函数/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/","excerpt":"函数是基本的代码块，用于执行一个任务。 Go 语言至少要有个 main() 函数。 本文将介绍Go语言中函数的相关内容。","text":"函数是基本的代码块，用于执行一个任务。 Go 语言至少要有个 main() 函数。 本文将介绍Go语言中函数的相关内容。 函数Go语言中支持函数、匿名函数、闭包。 函数定义Go语言中定义函数使用关键字func，如下： 123func 函数名(参数1,参数2)(返回值1,返回值2)&#123; 函数体&#125; 函数名：命名规则与变量相同 参数：参数由参数变量和参数变量类型组成 返回值：返回值由返回值变量和返回值类型组成，也可以只写返回值的类型。Go语言支持多个返回值，须用()包裹。 具体用以下例子说明： 例1例2123func mysum(x int, y int) int &#123; return x + y&#125;123func myhello()&#123; fmt.Println(&quot;Hello Boy!&quot;)&#125; 函数调用在定义了函数之后，可以通过函数名()的方式对函数进行调用。 例如调用上述定义的两个函数，代码如下： 12345func main()&#123; myhello(); ret := mysum(1, 2) fmt.Println(ret)&#125; 参数类型简写可变参数函数中的参数如果相邻变量的类型相同，则可以省略类型，只留一个，例如： 123func mysum(x, y int) int &#123; return x + y&#125;可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加...来表示。 可变参数通常要作为函数的最后一个参数 例如： 12345678910111213141516func mysum2(x ...int) int &#123; fmt.Println(x) //x是一个切片 sum :=0 for _, v := range x&#123; sum = sum + v &#125; return sum&#125;func main()&#123; ret1 := mysum2() ret2 := mysum2(10) ret3 := mysum3(10, 20, 30) fmt.Println(ret1,ret2,ret3)&#125; 返回值Go语言中通过关键字return返回 多返回值返回值命名返回值补充Go语言中函数支持多个返回值，函数如果有多个返回值时，必须用()将返回值括起来 12345func myfunc(x, y int)(int, int)&#123; sum := x + y sub := x - y return sum,sub&#125;函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。 例如： 12345func myfunc(x, y int) (sum, sub int) &#123; sum = x + y sub = x - y return&#125;当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。 123456func myfunc(x string) []int &#123; if x == &quot;&quot; &#123; return nil // 没必要返回[]int&#123;&#125; &#125; ...&#125; 函数进阶函数类型和变量使用type关键字来定义一个函数类型，格式如下： 1type mytype func(int, int) int 上面的语句定义了一个mytype类型，一种函数类型，且这种函数接受两个int类型的参数并且返回一个int类型的返回值。简单点来说，凡是满足这个条件的函数都是mytype类型的函数，例如： 12345678910111213141516171819package mainimport &quot;fmt&quot;func add(x, y int) int &#123; return x + y&#125;func sub(x, y int) int &#123; return x - y&#125;func main() &#123; type mytype func(int, int) int var c mytype c = add //将函数add赋值给变量c fmt.Println(c(1, 2)) // 可以像add一样调用c&#125; 高阶函数函数作为参数Go语言中，函数可以作为参数。例如： 12345678910111213141516package mainimport &quot;fmt&quot;func add(x, y int) int &#123; return x + y&#125;func myfunc(x, y int, canshu func(int, int) int) int &#123; return canshu(x, y)&#125;func main() &#123; ret1 := myfunc(1, 2, add) fmt.Println(ret1)&#125; 也可以使用定义函数类型 12345678910111213141516171819package mainimport &quot;fmt&quot;func add(x, y int) int &#123; return x + y&#125;type mytype func(x, y int) intfunc myfunc(x, y int, canshu mytype) int &#123; return canshu(x, y)&#125;func main() &#123; ret1 := myfunc(1, 2, add) fmt.Println(ret1)&#125; 函数作为返回值Go语言中，函数可以作为返回值 1//待补充 匿名函数和闭包匿名函数Go语言中函数内部定义函数与之前有所不同，只能定义匿名函数。匿名函数就是没有函数名的函数，格式如下： 123func(参数)(返回值)&#123; 函数体&#125; 匿名函数因为没有函数名，没办法想普通函数一样被调用，所以匿名函数需要保存到某个变量或者立即执行该函数： 1234567891011func main()&#123; add :=func(x, y int)&#123;//将匿名函数保存到变量中 fmt.Println(x + y) &#125; add(10,20)//通过变量调用匿名函数 //自执行函数，匿名函数定义完加()直接执行 func(x, y int)&#123; fmt.Println(x + y) &#125;(10, 20)&#125; 闭包闭包指的是一个函数和其相关的引用环境组合而成的实体。简单点说，闭包 = 函数 + 引用环境。例如： 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func adder() func(int) int &#123; var x int return func(y int) int &#123; x += y return x &#125;&#125;func main() &#123; var f = adder() fmt.Println(f(10)) //10 fmt.Println(f(20)) //30 fmt.Println(f(30)) //60 f1 := adder() fmt.Println(f1(40)) //40 fmt.Println(f1(50)) //90&#125; 变量f是一个函数并且它引用了其外部作用域中x变量，此时f是一个闭包。在f的生命周期内，变量x也一直有效。 闭包进阶示例示例1示例212345678910111213141516171819202122package mainimport &quot;fmt&quot;func adder2(x int) func(int) int &#123; return func(y int) int &#123; x += y return x &#125;&#125;func main() &#123; var f = adder2(10) fmt.Println(f(10)) //20 fmt.Println(f(20)) //40 fmt.Println(f(30)) //70 f1 := adder2(20) fmt.Println(f1(40)) //60 fmt.Println(f1(50)) //110&#125;12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func myfunc(base int) (func(int) int, func(int) int) &#123; add := func(i int) int &#123; base += i return base &#125; sub := func(i int) int &#123; base -= i return base &#125; return add, sub&#125;func main() &#123; f1, f2 := myfunc(10) fmt.Println(f1(1), f2(2)) //11 9 fmt.Println(f1(3), f2(4)) //12 8 fmt.Println(f1(5), f2(6)) //13 7&#125; defer语句Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句最先被执行，和C语言中栈的顺序一样 例如： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;start&quot;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(&quot;end&quot;)&#125; 运行结果： 12345startend321 利用defer语句延迟调用的特性，可以很方便的处理资源释放的问题","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"函数","slug":"函数","permalink":"https://www.niuwx.cn/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"Go语言基础之map","slug":"Go语言基础之map","date":"2021-03-17T05:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之map/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/","excerpt":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。","text":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。 mapmap是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 map定义Go语言中 map的定义语法如下： 1map[KeyType]ValueType 其中， KeyType:表示键的类型。 ValueType:表示键对应的值的类型。 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为： 1make(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。 map基本使用map中的数据都是成对出现的，map的基本使用示例代码如下： 12345678func main() &#123; scoreMap := make(map[string]int, 8) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[&quot;小明&quot;]) fmt.Printf(&quot;type of a:%T\\n&quot;, scoreMap)&#125; 输出： 123map[小明:100 张三:90]100type of a:map[string]int map也支持在声明的时候填充元素，例如： 1234567func main() &#123; userInfo := map[string]string&#123; &quot;username&quot;: &quot;沙河小王子&quot;, &quot;password&quot;: &quot;123456&quot;, &#125; fmt.Println(userInfo) //&#125; 判断某个键是否存在Go语言中有个判断map中键是否存在的特殊写法，格式如下: 1value, ok := map[key] 举个例子： 123456789101112func main() &#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 v, ok := scoreMap[&quot;张三&quot;] if ok &#123; fmt.Println(v) &#125; else &#123; fmt.Println(&quot;查无此人&quot;) &#125;&#125; map的遍历Go语言中使用for range遍历map。 123456789func main() &#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 scoreMap[&quot;娜扎&quot;] = 60 for k, v := range scoreMap &#123; fmt.Println(k, v) &#125;&#125; 但我们只想遍历key的时候，可以按下面的写法： 123456789func main() &#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 scoreMap[&quot;娜扎&quot;] = 60 for k := range scoreMap &#123; fmt.Println(k) &#125;&#125; 注意： 遍历map时的元素顺序与添加键值对的顺序无关。 使用delete()函数删除键值对使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下： 1delete(map, key) 其中， map:表示要删除键值对的map key:表示要删除的键值对的键 示例代码如下： 12345678910func main()&#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 scoreMap[&quot;娜扎&quot;] = 60 delete(scoreMap, &quot;小明&quot;)//将小明:100从map中删除 for k,v := range scoreMap&#123; fmt.Println(k, v) &#125;&#125; 按照指定顺序遍历map12345678910111213141516171819202122func main() &#123; rand.Seed(time.Now().UnixNano()) //初始化随机数种子 var scoreMap = make(map[string]int, 200) for i := 0; i &lt; 100; i++ &#123; key := fmt.Sprintf(&quot;stu%02d&quot;, i) //生成stu开头的字符串 value := rand.Intn(100) //生成0~99的随机整数 scoreMap[key] = value &#125; //取出map中的所有key存入切片keys var keys = make([]string, 0, 200) for key := range scoreMap &#123; keys = append(keys, key) &#125; //对切片进行排序 sort.Strings(keys) //按照排序后的key遍历map for _, key := range keys &#123; fmt.Println(key, scoreMap[key]) &#125;&#125; 元素为map类型的切片下面的代码演示了切片中的元素为map类型时的操作： 123456789101112131415func main() &#123; var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice &#123; fmt.Printf(&quot;index:%d value:%v\\n&quot;, index, value) &#125; fmt.Println(&quot;after init&quot;) // 对切片中的map元素进行初始化 mapSlice[0] = make(map[string]string, 10) mapSlice[0][&quot;name&quot;] = &quot;小王子&quot; mapSlice[0][&quot;password&quot;] = &quot;123456&quot; mapSlice[0][&quot;address&quot;] = &quot;沙河&quot; for index, value := range mapSlice &#123; fmt.Printf(&quot;index:%d value:%v\\n&quot;, index, value) &#125;&#125; 值为切片类型的map下面的代码演示了map中值为切片类型的操作： 12345678910111213func main() &#123; var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(&quot;after init&quot;) key := &quot;中国&quot; value, ok := sliceMap[key] if !ok &#123; value = make([]string, 0, 2) &#125; value = append(value, &quot;北京&quot;, &quot;上海&quot;) sliceMap[key] = value fmt.Println(sliceMap)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"}]},{"title":"Go语言基础之切片","slug":"Go语言基础之切片","date":"2021-03-17T02:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之切片/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/","excerpt":"本文主要介绍Go语言中切片（slice）及它的基本使用。","text":"本文主要介绍Go语言中切片（slice）及它的基本使用。 引入因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如： 1234567func arraySum(x [3]int) int&#123; sum := 0 for _, v := range x&#123; sum = sum + v &#125; return sum&#125; 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如， 1a := [3]int&#123;1, 2, 3&#125; 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了，这样就难受的一批。而切片可以很好的解决这个问题 切片切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。 切片的定义声明切片类型的基本语法如下： 1var name []T name:表示变量名 T:表示切片中的元素类型 例如： 1234567891011121314func main() &#123; // 声明切片类型 var a []string //声明一个字符串切片 var b = []int&#123;&#125; //声明一个整型切片并初始化 var c = []bool&#123;false, true&#125; //声明一个布尔切片并初始化 var d = []bool&#123;false, true&#125; //声明一个布尔切片并初始化 fmt.Println(a) //[] fmt.Println(b) //[] fmt.Println(c) //[false true] fmt.Println(a == nil) //true fmt.Println(b == nil) //false fmt.Println(c == nil) //false // fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较&#125; 切片的长度和容量切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。 切片表达式简单切片表达式切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;=索引值&lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。 12345func main() &#123; a := [5]int&#123;1, 2, 3, 4, 5&#125; s := a[1:3] // s := a[low:high] fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\\n&quot;, s, len(s), cap(s))&#125; 输入结果如下： 1s:[2 3] len(s):2 cap(s):4 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度: 123a[2:] // 等同于 a[2:len(a)]a[:3] // 等同于 a[0:3]a[:] // 等同于 a[0:len(a)] 注意： 对于数组或字符串，如果0 &lt;= low &lt;= high &lt;= len(a)，则索引合法，否则就会索引越界（out of range）。 对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low &lt;= high。如果索引在运行时超出范围，就会发生运行时panic。 1234567func main() &#123; a := [5]int&#123;1, 2, 3, 4, 5&#125; s := a[1:3] // s := a[low:high] fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\\n&quot;, s, len(s), cap(s)) s2 := s[3:4] // 索引的上限是cap(s)而不是len(s) fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\\n&quot;, s2, len(s2), cap(s2))&#125; 输出结果如下： 12s:[2 3] len(s):2 cap(s):4s2:[5] len(s2):1 cap(s2):1 完整切片表达式对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式： 1a[low : high : max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。 12345func main() &#123; a := [5]int&#123;1, 2, 3, 4, 5&#125; t := a[1:3:5] fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\\n&quot;, t, len(t), cap(t))&#125; 输出结果如下： 1t:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)，其他条件和简单切片表达式相同。 使用make()函数构造切片我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下： 1make([]T, size, cap) 其中： T:切片的元素类型 size:切片中元素的数量 cap:切片的容量 举个例子： 123456func main() &#123; a := make([]int, 2, 10) fmt.Println(a) //[0 0] fmt.Println(len(a)) //2 fmt.Println(cap(a)) //10&#125; 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。 切片的本质切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。 多个切片指向同一数组时，对任一切片进行操作时，都有可能对其他切片造成影响 切片不能直接比较切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例： 123var s1 []int //len(s1)=0;cap(s1)=0;s1==nils2 := []int&#123;&#125; //len(s2)=0;cap(s2)=0;s2!=nils3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。 切片的赋值拷贝下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。 1234567func main() &#123; s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 切片遍历切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。 1234567891011func main() &#123; s := []int&#123;1, 3, 5&#125; for i := 0; i &lt; len(s); i++ &#123; fmt.Println(i, s[i]) &#125; for index, value := range s &#123; fmt.Println(index, value) &#125;&#125; append()方法为切片添加元素Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。 1234567func main()&#123; var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int&#123;5, 6, 7&#125; s = append(s, s2...) // [1 2 3 4 5 6 7]&#125; 注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。 12var s []ints = append(s, 1, 2, 3) 没有必要像下面的代码一样初始化一个切片再传入append()函数使用， 12345s := []int&#123;&#125; // 没有必要初始化s = append(s, 1, 2, 3)var s = make([]int) // 没有必要初始化s = append(s, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。 举个例子： 12345678func main() &#123; //append()添加元素和切片扩容 var numSlice []int for i := 0; i &lt; 10; i++ &#123; numSlice = append(numSlice, i) fmt.Printf(&quot;%v len:%d cap:%d ptr:%p\\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice) &#125;&#125; 输出： 12345678910[0] len:1 cap:1 ptr:0xc0000a8000[0 1] len:2 cap:2 ptr:0xc0000a8040[0 1 2] len:3 cap:4 ptr:0xc0000b2020[0 1 2 3] len:4 cap:4 ptr:0xc0000b2020[0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000[0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000[0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000[0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000[0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000[0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b8000 从上面的结果可以看出： append()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。 append()函数还支持一次性追加多个元素。 例如： 123456789var citySlice []string// 追加一个元素citySlice = append(citySlice, &quot;北京&quot;)// 追加多个元素citySlice = append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)// 追加切片a := []string&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;citySlice = append(citySlice, a...)fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆] 使用copy()函数复制切片首先我们来看一个问题： 123456789func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := a fmt.Println(a) //[1 2 3 4 5] fmt.Println(b) //[1 2 3 4 5] b[0] = 1000 fmt.Println(a) //[1000 2 3 4 5] fmt.Println(b) //[1000 2 3 4 5]&#125; 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。 Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下： 1copy(destSlice, srcSlice []T) 其中： srcSlice: 数据来源切片 destSlice: 目标切片 举个例子： 1234567891011func main() &#123; // copy()复制切片 a := []int&#123;1, 2, 3, 4, 5&#125; c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1 2 3 4 5] c[0] = 1000 fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1000 2 3 4 5]&#125; 从切片中删除元素Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下： 1234567func main() &#123; // 从切片中删除元素 a := []int&#123;30, 31, 32, 33, 34, 35, 36, 37&#125; // 要删除索引为2的元素 a = append(a[:2], a[3:]...) fmt.Println(a) //[30 31 33 34 35 36 37]&#125; 总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"}]},{"title":"Go语言基础之数组","slug":"Go语言基础之数组","date":"2021-03-16T14:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之数组/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/","excerpt":"本文主要介绍Go语言中数组（array）及它的基本使用。","text":"本文主要介绍Go语言中数组（array）及它的基本使用。 Array(数组)数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法： 12// 定义一个长度为3元素类型为int的数组avar a [3]int 数组定义：1var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。 123var a [3]intvar b [4]inta = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。 数组的初始化数组的初始化也有很多方式。 方法一初始化数组时可以使用初始化列表来设置数组元素的值。 12345678func main() &#123; var testArray [3]int //数组会初始化为int类型的零值 var numArray = [3]int&#123;1, 2&#125; //使用指定的初始值完成初始化 var cityArray = [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; //使用指定的初始值完成初始化 fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2 0] fmt.Println(cityArray) //[北京 上海 深圳]&#125; 方法二按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如： 12345678910func main() &#123; var testArray [3]int var numArray = [...]int&#123;1, 2&#125; var cityArray = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2] fmt.Printf(&quot;type of numArray:%T\\n&quot;, numArray) //type of numArray:[2]int fmt.Println(cityArray) //[北京 上海 深圳] fmt.Printf(&quot;type of cityArray:%T\\n&quot;, cityArray) //type of cityArray:[3]string&#125; 方法三我们还可以使用指定索引值的方式来初始化数组，例如: 12345func main() &#123; a := [...]int&#123;1: 1, 3: 5&#125; fmt.Println(a) // [0 1 0 5] fmt.Printf(&quot;type of a:%T\\n&quot;, a) //type of a:[4]int&#125; 数组的遍历遍历数组a有以下两种方法： 123456789101112func main() &#123; var a = [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; // 方法1：for循环遍历 for i := 0; i &lt; len(a); i++ &#123; fmt.Println(a[i]) &#125; // 方法2：for range遍历 for index, value := range a &#123; fmt.Println(index, value) &#125;&#125; 多维数组Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。 二维数组的定义123456789func main() &#123; a := [3][2]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;, &#125; fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]] fmt.Println(a[2][1]) //支持索引取值:重庆&#125; 二维数组的遍历12345678910111213func main() &#123; a := [3][2]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;, &#125; for _, v1 := range a &#123; for _, v2 := range v1 &#123; fmt.Printf(&quot;%s\\t&quot;, v2) &#125; fmt.Println() &#125;&#125; 输出： 123北京 上海 广州 深圳 成都 重庆 注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如： 123456789101112//支持的写法a := [...][2]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,&#125;//不支持多维数组的内层使用...b := [3][...]string&#123; &#123;&quot;北京&quot;, &quot;上海&quot;&#125;, &#123;&quot;广州&quot;, &quot;深圳&quot;&#125;, &#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,&#125; 数组是值类型数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。 12345678910111213141516171819func modifyArray(x [3]int) &#123; x[0] = 100&#125;func modifyArray2(x [3][2]int) &#123; x[2][0] = 100&#125;func main() &#123; a := [3]int&#123;10, 20, 30&#125; modifyArray(a) //在modify中修改的是a的副本x fmt.Println(a) //[10 20 30] b := [3][2]int&#123; &#123;1, 1&#125;, &#123;1, 1&#125;, &#123;1, 1&#125;, &#125; modifyArray2(b) //在modify中修改的是b的副本x fmt.Println(b) //[[1 1] [1 1] [1 1]]&#125; 注意： 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"}]},{"title":"Go语言基础之流程控制","slug":"Go语言基础之流程控制","date":"2021-03-16T11:30:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之流程控制/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。 Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。","text":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。 Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 if else (分支结构)if条件判断基本写法Go语言中if条件判断的格式如下： 1234567if 表达式1 &#123; 分支1&#125; else if 表达式2 &#123; 分支2&#125; else&#123; 分支3&#125; Go语言规定与if匹配的左括号&#123;必须与if和表达式放在同一行，&#123;放在其他位置会触发编译错误。 同理，与else匹配的&#123;也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。 例如： 12345678910func myfunc() &#123; score := 65 if score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt;= 85 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; if条件判断特殊写法if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子： 123456789func myfunc() &#123; if score := 65; score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt;= 85 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; 两种写法有什么不同呢？ for (循环结构)Go 语言中的所有循环类型均可以使用for关键字来完成。 for循环的基本格式如下： 123for 初始语句;条件表达式;结束语句&#123; 循环体语句&#125; 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。 12345func myfunc1() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125; for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如： 123456func myfunc2() &#123; i := 0 for ; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125; for循环的初始语句和结束语句都可以省略，例如： 1234567func myfunc3() &#123; i := 0 for i &lt; 10 &#123; fmt.Println(i) i++ &#125;&#125; 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。 无限循环 Folding 点击打开 123for &#123; 循环体语句&#125; for循环可以通过break、goto、return、panic语句强制退出循环。 for range(键值循环)Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律： 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 switch case使用switch语句可方便地对大量的值进行条件判断。 1234567891011121314151617func switch1() &#123; finger := 3 switch finger &#123; case 1: fmt.Println(&quot;大拇指&quot;) case 2: fmt.Println(&quot;食指&quot;) case 3: fmt.Println(&quot;中指&quot;) case 4: fmt.Println(&quot;无名指&quot;) case 5: fmt.Println(&quot;小拇指&quot;) default: fmt.Println(&quot;无效的输入！&quot;) &#125;&#125; Go语言规定每个switch只能有一个default分支。 一个分支可以有多个值，多个case值中间使用英文逗号分隔。 12345678910func Switch2() &#123; switch n := 7; n &#123; case 1, 3, 5, 7, 9: fmt.Println(&quot;奇数&quot;) case 2, 4, 6, 8: fmt.Println(&quot;偶数&quot;) default: fmt.Println(n) &#125;&#125; 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如： 12345678910111213func switch3() &#123; age := 30 switch &#123; case age &lt; 25: fmt.Println(&quot;好好学习！&quot;) case age &gt; 25 &amp;&amp; age &lt; 35: fmt.Println(&quot;好好工作！&quot;) case age &gt; 60: fmt.Println(&quot;好好享受！&quot;) default: fmt.Println(&quot;长命百岁！&quot;) &#125;&#125; fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。 1234567891011121314func switch4() &#123; s := &quot;a&quot; switch &#123; case s == &quot;a&quot;: fmt.Println(&quot;a&quot;) fallthrough case s == &quot;b&quot;: fmt.Println(&quot;b&quot;) case s == &quot;c&quot;: fmt.Println(&quot;c&quot;) default: fmt.Println(&quot;...&quot;) &#125;&#125; 输出： 12ab 注意Go与C中switch的区别 goto(跳转到指定标签)goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时： 1234567891011121314151617func goto1() &#123; var breakFlag bool for i := 0; i &lt; 10; i++ &#123; for j := 0; j &lt; 10; j++ &#123; if j == 2 &#123; // 设置退出标签 breakFlag = true break &#125; fmt.Printf(&quot;%v-%v\\n&quot;, i, j) &#125; // 外层for循环判断 if breakFlag &#123; break &#125; &#125;&#125; 使用goto语句能简化代码： 123456789101112131415func goto2() &#123; for i := 0; i &lt; 10; i++ &#123; for j := 0; j &lt; 10; j++ &#123; if j == 2 &#123; // 设置退出标签 goto breakTag &#125; fmt.Printf(&quot;%v-%v\\n&quot;, i, j) &#125; &#125; return // 标签breakTag: fmt.Println(&quot;结束for循环&quot;)&#125; break(跳出循环)break语句可以结束for、switch和select的代码块。 break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子： 123456789101112func break1() &#123;BREAKDEMO1: for i := 0; i &lt; 10; i++ &#123; for j := 0; j &lt; 10; j++ &#123; if j == 2 &#123; break BREAKDEMO1 &#125; fmt.Printf(&quot;%v-%v\\n&quot;, i, j) &#125; &#125; fmt.Println(&quot;...&quot;)&#125; continue(继续下次循环)continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。 在 continue语句后添加标签时，表示开始标签对应的循环。例如： 123456789101112func continue1() &#123;forloop1: for i := 0; i &lt; 5; i++ &#123; // forloop2: for j := 0; j &lt; 5; j++ &#123; if i == 2 &amp;&amp; j == 2 &#123; continue forloop1 &#125; fmt.Printf(&quot;%v-%v\\n&quot;, i, j) &#125; &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"}]},{"title":"Go语言基础之运算符","slug":"Go语言基础之运算符","date":"2021-03-16T06:05:15.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之运算符/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"运算符用于在程序运行时执行数学或逻辑运算。","text":"运算符用于在程序运行时执行数学或逻辑运算。 Go 语言内置的运算符有五类： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 算数运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 注意： ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。 关系运算符 运算符 描述 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 &gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 &gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 &lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 &lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 逻辑运算符 运算符 描述 &amp;&amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 位运算符位运算符对整数在内存中的二进制位进行操作。 运算符 描述 &amp; 参与运算的两数各对应的二进位相与。 （两位均为1才为1） | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1） ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） &lt;&lt; 左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 &gt;&gt; 右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。 赋值运算符 运算符 描述 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 &lt;&lt;= 左移后赋值 &gt;&gt;= 右移后赋值 &amp;= 按位与后赋值 |= 按位或后赋值 ^= 按位异或后赋值","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"}]},{"title":"Go语言基础之基本数据类型","slug":"Go语言基础之基本数据类型","date":"2021-03-15T05:31:34.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之基本数据类型/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。","text":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。 基本数据类型整型整数分为以下两个大类： 按长度分为：int8，int16，int64 对应的无符号整型：uint16，uint32，uint64 其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 特殊整型 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 浮点型Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。 打印浮点数时，可以使用fmt包配合动词%f，代码如下： 123456789package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; fmt.Printf(&quot;%f\\n&quot;, math.Pi) fmt.Printf(&quot;%.2f\\n&quot;, math.Pi)&#125; 复数complex64和complex128 具体用法如下： 123456var c1 complex64c1 = 1 + 2ivar c2 complex128c2 = 2 + 3ifmt.Println(c1)fmt.Println(c2) 布尔值Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。 字符串Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(&quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如： 12s1 := &quot;hello&quot;s2 := &quot;你好&quot; 转义字符 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\&#39; 单引号 \\&quot; 双引号 \\\\ 反斜杠 例如，我们要打印Windows平台的文件路径 1234567package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;str := \\&quot;c:\\\\Code\\\\lesson1\\\\go.exe\\&quot;&quot;)&#125; 多行字符串Go语言中要定义一个多行字符串时，就必须使用反引号字符： 12345s1 := `第一行第二行第三行`fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。 字符串的常用操作 len(str) 求长度 + 或 fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 byte和rune类型组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如： 12var a := &#x27;中&#x27;var b := &#x27;x&#x27; Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。 如下，可以知道rune和byte的区别： 123456789101112// 遍历字符串func traversalString() &#123; s := &quot;GO你好&quot; for i := 0; i &lt; len(s); i++ &#123; //byte fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i]) &#125; fmt.Println() for _, r := range s &#123; //rune fmt.Printf(&quot;%v(%c) &quot;, r, r) &#125; fmt.Println()&#125; 这是我们的输出结果 1271(G) 79(O) 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 71(G) 79(O) 20320(你) 22909(好) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。 字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。 修改字符串要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。 123456789101112func changeString() &#123; s1 := &quot;big&quot; // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = &#x27;p&#x27; fmt.Println(string(byteS1)) s2 := &quot;白萝卜&quot; runeS2 := []rune(s2) runeS2[0] = &#x27;红&#x27; fmt.Println(string(runeS2))&#125; 类型转化强制类型转换的基本语法如下： 1T(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等 比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型 1234567func sqrtDemo() &#123; var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"整型","slug":"整型","permalink":"https://www.niuwx.cn/tags/%E6%95%B4%E5%9E%8B/"},{"name":"浮点型","slug":"浮点型","permalink":"https://www.niuwx.cn/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"},{"name":"布尔型","slug":"布尔型","permalink":"https://www.niuwx.cn/tags/%E5%B8%83%E5%B0%94%E5%9E%8B/"},{"name":"字符串","slug":"字符串","permalink":"https://www.niuwx.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://www.niuwx.cn/tags/%E5%88%87%E7%89%87/"}]},{"title":"Go语言基础之变量与常量","slug":"Go语言基础之变量与常量","date":"2021-03-15T03:31:34.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Go语言基础之变量与常量/","link":"","permalink":"https://www.niuwx.cn/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","excerpt":"变量和常量是编程中必不可少的部分，也是很好理解的一部分。","text":"变量和常量是编程中必不可少的部分，也是很好理解的一部分。 标识符与关键字标识符关于Go语言中的命名规则，与C类似。Go语言中标识符由字母、数字和_(下划线)组成，并且只能以字母和_开头。例如aaa,_ ,_123,a123 关键字关键字是指编程语言中预先定义好的具有特殊含义的标识符。且不能将关键字和保留字作为变量名 123456//25个关键字break default func interface selectcase defer go map struct chan const continue else fallthroughif for goto package range import return switch type var 123456//37个保留字Constants: true false iota nilTypes: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune stringerror Functions: make len cap new append copy close delete complex real imag panic recover 变量变量类型变量的功能是存储数据，不同类型的变量存储不同类型的数据。 常见变量的数据类型有：整型、浮点型、布尔型等。 Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。 变量声明Go语言声明变量的格式为: 1var 变量名 变量类型 例如： 123var name stringvar age intvar isOK bool 当然，在Go语言中，可以批量声明变量 123456var( a string b int c bool d float32) 变量初始化Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。 当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下： 1var 变量名 类型 = 值 例如： 12var name string = &quot;Q1mi&quot;var age int = 18 同样，也支持多个变量初始化 1var name, age = &quot;Q1mi&quot;, 20 类型推导 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。 12var name = &quot;Q1mi&quot;var age = 18 短变量声明 在函数内部，可以使用更简略的:=方式声明并初始化变量。 1234567891011package mainimport &quot;fmt&quot;// 全局变量mvar m = 100func main() &#123; n := 10 m := 200 // 此处声明局部变量m fmt.Println(m, n)&#125; 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量。 匿名变量用一个下划线_表示。 例如： 123456789func test() (int, string) &#123; return 10, &quot;hahaha&quot;&#125;func main() &#123; x, _ := test() _, y := test() fmt.Println(&quot;x=&quot;, x) fmt.Println(&quot;y=&quot;, y)&#125; 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 注意事项： 函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。 常量相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把ar换成了const，常量在定义的时候必须赋值。 12const pi = 3.1415const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。 多个常量也可以一起声明： 1234const ( pi = 3.1415 e = 2.7182) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如： 12345const ( n1 = 100 n2 n3)","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"变量与常量","slug":"变量与常量","permalink":"https://www.niuwx.cn/tags/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"}]},{"title":"Golang学习笔记","slug":"Golang学习笔记","date":"2021-03-14T02:31:34.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Golang学习笔记/","link":"","permalink":"https://www.niuwx.cn/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"这里将记录Golang学习的笔记 关于开发环境 VScode Golang编译环境 Goproxy中国","text":"这里将记录Golang学习的笔记 关于开发环境 VScode Golang编译环境 Goproxy中国 Go基础Go语言基础之变量与常量Go语言基础之基本数据类型Go语言基础之运算符Go语言基础之流程控制Go语言基础之数组Go语言基础之切片Go语言基础之mapGo语言基础之函数Go语言基础之指针Go语言基础之结构体（一）Go语言基础之结构体（二）Go语言基础之接口Go语言基础之并发","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"快速幂","slug":"快速幂","date":"2021-03-10T12:31:34.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"快速幂/","link":"","permalink":"https://www.niuwx.cn/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"引入例题hdu1097 这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法 点击展开 1234567long long fastPower(long long base, long long power)&#123; long long ans = 1; for(int i = 0; i &lt; power; i++)&#123; ans *=base; &#125; return ans % 10;&#125;","text":"引入例题hdu1097 这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法 点击展开 1234567long long fastPower(long long base, long long power)&#123; long long ans = 1; for(int i = 0; i &lt; power; i++)&#123; ans *=base; &#125; return ans % 10;&#125; 那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？ 12345678910int fastPower(long long base, long long power)&#123; int ans = 1; base %= 10; for(int i = 0; i &lt; power; i++)&#123; ans *= base; if(ans &gt; 9) ans %= 10; &#125; return ans;&#125; 结果同样，如果数据过大，还是会超时。 快速幂 取模的运算法则 $(a+b) mod M = (amodM + bmodM)modM$$(a-b)modM = (amodM - bmodM)modM$$(a*b)modM = (amodM * bmodM)modM$ 入门快速幂算法可以高效快速的算出$a^n$。 下面举一个例子 如果计算$2^{10}$ $2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 尽量将指数变小，如下 $2^{10} = (2*2)^5 = 4^5$ 此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。 那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样 $2^{10} = 4^4*4^1$ 将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作： $2^{10} = 16^2*4^1$ 将指数再次缩小一半 $2^{10} = 256^1*4^1$ 此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，得到的结果是变化过程中所有指数为奇数时的底数的乘积 初步实现用代码实现上面的算法： 123456789101112131415long long fastPower(long long base, long long power) &#123; long long result = 1; while (power) &#123; if (power % 2) &#123; power -= 1; result = result * base % 10; power /= 2; base = base * base % 10; &#125; else &#123; power /= 2; base = base * base % 10; &#125; &#125; return result % 10;&#125; 优化1.由于if、else中有重复语句 12power /= 2;base = base * base % 10; 2.且在整形运算中 12power -=1;power /=2; 可以压缩成下面一句 1power /=2; 于是代码就可以压缩成以下这样： 12345678910long long fastPower(long long base, long long power) &#123; long long result = 1; while (power) &#123; if (power % 2) result = result * base % 10; power /= 2; base = base * base % 10; &#125; return result % 10;&#125; 再次优化在C/C++中可以利用更快位运算来代替一些计算，例如 12power % 2 == 1;power &amp; 1 == 1;//位运算 12power /=2;power &gt;&gt;= 1;//位运算 于是代码就变成了这样： 1234567891011long long fastPower(long long base, long long power) &#123; long long result = 1; while (power) &#123; if (power &amp; 1) result = result * base % 10; power &gt;&gt;= 1; base = base * base % 10; &#125; return result % 10;&#125;","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.niuwx.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"算法","slug":"算法","permalink":"https://www.niuwx.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"STL","slug":"STL","date":"2021-02-04T08:01:36.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"STL/","link":"","permalink":"https://www.niuwx.cn/STL/","excerpt":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）","text":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator） 容器使用容器时要在头文件中引入 序列式容器序列的元素的位置是由进入容器的时间和地点决定的 vectorvector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void PrintVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//初始化void test01() &#123; vector&lt;int&gt; v1; //默认构造 int arr[] = &#123;10, 20, 30, 40&#125;; vector&lt;int&gt; v2(arr, arr + sizeof(arr) / sizeof(int)); vector&lt;int&gt; v3(v2.begin(), v2.end()); vector&lt;int&gt; v4(v3); PrintVector(v2); PrintVector(v3); PrintVector(v4);&#125;//常用赋值操作void test02() &#123; int arr[] = &#123;10, 20, 30, 40&#125;; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); //成员方法 vector&lt;int&gt; v2; v2.assign(v1.begin(), v1.end()); //重载= vector&lt;int&gt; v3; v3 = v2; int arr1[] = &#123;100, 200, 300, 400&#125;; vector&lt;int&gt; v4(arr1, arr1 + sizeof(arr1) / sizeof(int)); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl; //交换 v4.swap(v1); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4);&#125;//大小操作void test03() &#123; int arr[] = &#123;100, 200, 300, 400&#125;; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); cout &lt;&lt; &quot;size: &quot; &lt;&lt; v1.size() &lt;&lt; endl; if (v1.empty()) &#123; cout &lt;&lt; &quot;空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不空&quot; &lt;&lt; endl; &#125; PrintVector(v1); v1.resize(2); PrintVector(v1); v1.resize(6, 1); //不写默认零 PrintVector(v1); for (int i = 0; i &lt; 10000; i++) &#123; v1.push_back(i); &#125; cout &lt;&lt; v1.size() &lt;&lt; endl; //长度、大小 cout &lt;&lt; v1.capacity() &lt;&lt; endl; //容量&#125;//vector存取数据void test04() &#123; int arr[] = &#123;100, 200, 300, 400&#125;; vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;front: &quot; &lt;&lt; v1.front() &lt;&lt; endl; //第一个元素 cout &lt;&lt; &quot;back: &quot; &lt;&lt; v1.back() &lt;&lt; endl; //最后一个元素&#125;//插入和删除void test05() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); //头插法 v.insert(v.begin(), 30); //尾插法 v.insert(v.end(), 40); PrintVector(v); v.insert(v.begin() + 2, 100); //插到第二个位置 //vector支持随机访问 //支持数组下标，一般都支持随机访问 //迭代器可以直接+-操作 PrintVector(v); //删除 v.erase(v.begin()); PrintVector(v); v.erase(v.begin() + 1, v.end()); PrintVector(v); v.clear(); cout &lt;&lt; &quot;size: &quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;//巧用swap缩减空间void test06() &#123; //vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗 vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;size: &quot; &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl; v.resize(10); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl; //收缩空间 vector&lt;int&gt;(v).swap(v); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; endl; PrintVector(v);&#125;void test07() &#123; //reserve预留空间 resize区别 int num = 0; int* address = NULL; vector&lt;int&gt; v; v.reserve(100000); //预先分配 for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); if (address != &amp;v[0]) &#123; num++; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; //如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率&#125;int main() &#123; //test01(); //test02(); //test03(); //test04(); //test05(); //test06(); test07(); return 0;&#125; dequedeque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除 分段连续的内存空间 支持随机访问 指定位置插入，会引起数据移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#define _CRT_SECURE_NO_WARNINGS#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;void PrintDeque(deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;//初始化void test01() &#123; deque&lt;int&gt; d1; deque&lt;int&gt; d2(10, 5); deque&lt;int&gt; d3(d2.begin(), d2.end()); deque&lt;int&gt; d4(d3); //打印 PrintDeque(d4); cout &lt;&lt; endl;&#125;//赋值、大小操作void test02() &#123; deque&lt;int&gt; d1; deque&lt;int&gt; d2; deque&lt;int&gt; d3; d1.assign(10, 5); d2.assign(d1.begin(), d1.end()); //迭代器指定区间赋值 d3 = d2; //等号赋值 d1.swap(d2); //交换两个空间的元素 if (d1.empty()) &#123; cout &lt;&lt; &quot;空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不空&quot; &lt;&lt; endl; &#125; d1.resize(5); //有十个，后五个扔掉&#125;//插入和删除void test03() &#123; deque&lt;int&gt; d1; d1.push_back(100); d1.push_front(200); d1.push_back(300); d1.push_back(400); d1.push_front(500); //500 200 100 300 400 PrintDeque(d1); int val = d1.front(); //拿到第一个数据 d1.pop_front(); //删除第一个，无返回值 val = d1.back(); d1.pop_back(); //删除最后一个元素&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125; list 双向链表 链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。 链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素 链表需要额外空间保留节点关系 不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;//初始化void test01() &#123; list&lt;int&gt; l1; list&lt;int&gt; l2(10, 10); list&lt;int&gt; l3(l2); list&lt;int&gt; l4(l3.begin(), l3.end()); //打印 for (list&lt;int&gt;::iterator it = l4.begin(); it != l4.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test02() &#123; list&lt;int&gt; l; l.push_back(100); l.push_front(200); l.insert(l.begin(), 300); l.insert(l.end(), 200); list&lt;int&gt;::iterator it = l.begin(); it++; l.insert(it, 500); //删除 //l.pop_back(); //l.pop_front(); //l.erase(l.begin(), l.end()); l.remove(200); //删除匹配的所有值 for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test03() &#123; list&lt;int&gt; l; l.assign(10, 10); list&lt;int&gt; l2; l2 = l; list&lt;int&gt; l3; l3.swap(l);&#125;//反转void test04() &#123; list&lt;int&gt; l; for (int i = 0; i &lt; 10; i++) &#123; l.push_back(i); &#125; for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; l.reverse(); //容器元素反转 for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;bool Mycompare(int val1, int val2) &#123; return val1 &gt; val2;&#125;//排序void test05() &#123; list&lt;int&gt; l; for (int i = 0; i &lt; 10; i++) &#123; l.push_back(rand() % 10); &#125; for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; l.sort(); for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //从大到小 l.sort(Mycompare); for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //算法sort 只支持可随机访问的容器 链表没有 //list的sort是自己的成员函数不是算法&#125;int main() &#123; //test01(); //test02(); //test04(); test05(); return 0;&#125; queue 先进先出 不提供迭代器，不能遍历，不支持随机访问 push 入队（队尾） pop 出队（队头） 1234567891011121314151617181920212223242526#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;void test01() &#123; queue&lt;int&gt; q;//创建队列 q.push(10); q.push(20); q.push(30); q.push(40); cout &lt;&lt; &quot;队尾元素: &quot; &lt;&lt; q.back() &lt;&lt; endl; //输出顺序 10,20,30,40 while (q.size() &gt; 0)&#123; cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;//输出队头 q.pop();//删除队头 &#125;&#125;int main() &#123; test01(); return 0;&#125; stack 先进后出 push 压栈 pop 出栈 栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素 123456789101112131415161718192021222324252627282930313233343536#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;void test01()&#123; //初始化 stack&lt;int&gt; s1; stack&lt;int&gt; s2(s1); //stack操作 s1.push(10); s1.push(20); s1.push(30); s1.push(100); cout &lt;&lt; &quot;栈顶元素：&quot; &lt;&lt; s1.top() &lt;&lt; endl; s1.pop();//删除栈顶元素 cout &lt;&lt; &quot;栈顶元素：&quot; &lt;&lt; s1.top() &lt;&lt; endl; //打印栈容器数据 while (!s1.empty()) &#123; cout &lt;&lt; s1.top() &lt;&lt; &quot; &quot;; s1.pop(); &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; s1.size() &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125; 关联式容器容器的规则是固定的，与元素进入容器的时间和地点无关 set/multisetset表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改 以红黑树为底层机制，查找效率非常好 set中不允许重复元素，multiset中允许重复元素 不可通过迭代器改变set元素的值，会破坏set组织 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;//仿函数 类class Mycompare &#123;public: bool operator()(int v1, int v2) const &#123; //此处注意，要加const限定符 return v1 &gt; v2; &#125;&#125;;//set容器初始化void test01() &#123; set&lt;int, Mycompare&gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); //自动进行排序，默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //从大到小排序怎么办？#if 0 //赋值 set&lt;int&gt; s2; s2 = s1; //删除 s1.erase(s1.begin()); s1.erase(6); for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;size = &quot; &lt;&lt; s2.size() &lt;&lt; endl; s2.clear(); cout &lt;&lt; &quot;size = &quot; &lt;&lt; s2.size() &lt;&lt; endl;#endif&#125;//set查找void test02() &#123; //实值 set&lt;int&gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); set&lt;int&gt;::iterator ret = s1.find(4); if (ret == s1.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *ret &lt;&lt; endl; &#125; //找到第一个大于等于的元素 ret = s1.lower_bound(4); if (ret == s1.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *ret &lt;&lt; endl; &#125; //找到第一个大于的元素 ret = s1.upper_bound(4); if (ret == s1.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *ret &lt;&lt; endl; &#125; //equal_range 返回lower_bound和upper_bound的值 pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt; pret = s1.equal_range(4); if (pret.first == s1.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到&quot; &lt;&lt; endl; cout &lt;&lt; *pret.first &lt;&lt; endl; &#125; if (pret.second == s1.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到&quot; &lt;&lt; endl; cout &lt;&lt; *pret.second &lt;&lt; endl; &#125;&#125;class Person &#123;public: Person(int id, int age) : id(id), age(age)&#123;&#125;; int id; int age;&#125;;class PersonCompare &#123;public: bool operator()(const Person&amp; p1, const Person&amp; p2) const &#123; return p1.age &gt; p2.age; &#125;&#125;;void test03() &#123; set&lt;Person, PersonCompare&gt; sp; Person p1(10, 20), p2(30, 40), p3(50, 60); sp.insert(p1); sp.insert(p2); sp.insert(p3); for (set&lt;Person, PersonCompare&gt;::iterator it = sp.begin(); it != sp.end(); it++) &#123; cout &lt;&lt; (*it).id &lt;&lt; &quot; &quot; &lt;&lt; (*it).age &lt;&lt; endl; &#125; //查找 Person p4(90, 20); set&lt;Person, PersonCompare&gt;::iterator ret = sp.find(p4); //可找到，对应p1，按照age排序就按照age查找 if (ret == sp.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到&quot; &lt;&lt; endl; cout &lt;&lt; (*ret).id &lt;&lt; &quot; &quot; &lt;&lt; (*ret).age &lt;&lt; endl; &#125;&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125; 对组将两个值合并成一个值 1234567891011121314151617181920#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;using namespace std;void test01() &#123; pair&lt;int, int&gt; pair1(10, 20); cout &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl; pair&lt;int, string&gt; pair2 = make_pair(10, &quot;aaa&quot;); cout &lt;&lt; pair2.first &lt;&lt; &quot; &quot; &lt;&lt; pair2.second &lt;&lt; endl; pair&lt;int, string&gt; pair3 = pair2; cout &lt;&lt; pair3.first &lt;&lt; &quot; &quot; &lt;&lt; pair3.second &lt;&lt; endl;&#125;int main() &#123; test01(); return 0;&#125; map/multimap map与set区别，map具有键值和实值 所有元素根据键值自动排序 pair的第一个元素成为键值，第二个元素成为实值 map也是以红黑树为底层实现机制 不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值 multimap允许相同键值存在，map不允许 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;//map初始化void test01() &#123; //map容器模板参数：第一个参数key的类型，第二个参数value的类型 map&lt;int, int&gt; m; //插入数据 pair.first 对应key，pair.second 对应value //第一种 pair&lt;map&lt;int, int&gt;::iterator, bool&gt; ret = m.insert(pair&lt;int, int&gt;(10, 10)); //放入匿名对象 if (ret.second) &#123; cout &lt;&lt; &quot;第一次插入成功&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl; &#125; //第二种 ret = m.insert(make_pair(10, 20)); if (ret.second) &#123; cout &lt;&lt; &quot;第二次插入成功&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;插入失败&quot; &lt;&lt; endl; &#125; //第三种 m.insert(map&lt;int, int&gt;::value_type(30, 30)); //第四种 m[40] = 40; m[10] = 20; //如果key不存在，创建pair并插入 //如果key存在，修改value实值 //打印 for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; //*it取出来一个pair cout &lt;&lt; &quot;key = &quot; &lt;&lt; (*it).first &lt;&lt; &quot;, value = &quot; &lt;&lt; (*it).second &lt;&lt; endl; &#125; cout &lt;&lt; &quot;m[60] = &quot; &lt;&lt; m[60] &lt;&lt; endl; //访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零 for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; //*it取出来一个pair cout &lt;&lt; &quot;key = &quot; &lt;&lt; (*it).first &lt;&lt; &quot;, value = &quot; &lt;&lt; (*it).second &lt;&lt; endl; &#125;&#125;class MyKey &#123;public: MyKey(int index, int id) : index(index), id(id) &#123;&#125; int index; int id;&#125;;struct mycompare &#123; bool operator()(MyKey key1, MyKey key2) const &#123; return key1.index &gt; key2.index; &#125;&#125;;void test02() &#123; map&lt;MyKey, int, mycompare&gt; m; //需要排序，自定义类型，给定一个排序方法 m.insert(make_pair(MyKey(1, 2), 2)); m.insert(make_pair(MyKey(3, 4), 2)); for (map&lt;MyKey, int, mycompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; it-&gt;first.index &lt;&lt; &quot;;&quot; &lt;&lt; it-&gt;first.id &lt;&lt; &quot;;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125;//equal_rangevoid test03() &#123; map&lt;int, int&gt; m; m.insert(make_pair(1, 4)); m.insert(make_pair(2, 5)); m.insert(make_pair(3, 6)); pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt; ret = m.equal_range(2); if (ret.first-&gt;second) &#123; cout &lt;&lt; &quot;找到lower_bound&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl; &#125; if (ret.second-&gt;second) &#123; cout &lt;&lt; &quot;找到upper_bound&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; //test01(); //test02(); test03(); return 0;&#125; 对比 容器 vector deque list set multiset map multimap 典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言：是 否 元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快 元素安插移除 尾端 头尾两端 任何位置 - - - - 迭代器可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针 算法通过有限的步骤解决问题的方法","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.niuwx.cn/tags/STL/"},{"name":"C++","slug":"C","permalink":"https://www.niuwx.cn/tags/C/"}]},{"title":"并查集","slug":"并查集","date":"2021-02-03T12:02:57.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"并查集/","link":"","permalink":"https://www.niuwx.cn/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林”","text":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林” 并查集可以总结为三句话： “并”的意思是把两个有某些关系的结点并到一起 “查”的意思是查找一个结点的根节点 “并”的时候需要用到“查” 初始化1234567int father[len];//此数组定义在全局void Init(int n)&#123; for (int i = 0; i &lt; len; ++i) &#123;//len为结点总数 father[i] = i; &#125;&#125; 查初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点） 假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root. 如图即是对应关系 123456789//查（非递归算法）int FindRoot(int x)&#123; r = x; while(r != father[r])&#123;//自己是自己的爹即是找到了根结点 r = father[r]; &#125; return r;&#125; 1234//递归算法int FindRoot(int x)&#123; return x == father[x] ? x : FindRoot(father[x]);&#125; 并如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作； 相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作 12345678//并void merge(int x, int y)&#123; x = FindRoot(x); y = FindRoot(y); if(x != y)&#123; parent[y] = x; &#125;&#125; 例题hdu1213 问题描述今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。 例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上所以伊格纳修斯至少需要 2 张桌子。 输入输入以表示测试用例数的整数 T（1&lt;=T&lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1&lt;=N，M&lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。 输出对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。 示例输入12345678925 31 22 34 55 12 5 示例输出1224 这道题用一句话概括就是在一张桌子上，每个人都要有认识的人 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int father[1001];int find(int x) &#123; return father[x] == x ? x : find(father[x]);&#125;void merge (int x, int y) &#123; x = find(x); y = find(y); if (x != y) &#123; a[x] = y; &#125;&#125;int main(int argc, char const *argv[]) &#123; int t, m, n, x, y; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; father[i] = i; &#125; for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); merge(x, y); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (father[i] == i) &#123; cnt++; &#125; &#125; printf(&quot;%d\\n&quot;, cnt); &#125; return 0;&#125; 优化合并的优化 如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免 不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度 初始化代码如下 123456int father[len];int height[len];for(int i = 0; i &lt; len; i++)&#123; father[i] = i; height[i] = 1;//初始深度为1&#125; 123456789101112131415//并void merge(int x, int y)&#123; x = FindRoot(x); y = FindRoot(y); if(height[x] == height[y])&#123;//此处无需判断x，y根结点是否一致 height[x] = height[x] + 1; father[y] = x; &#125; else if(height[x] &gt; height [y])&#123; father[y] = x; &#125; else &#123; father[x] = y; &#125;&#125; 查询的优化12345678 //对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。//这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果int find (int x)&#123; if(x != parent[x])&#123; father[x] = find(father[x]); &#125; return father[x]; &#125; 此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并 但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下： 1234567891011121314int Find(int x)&#123; int r = x; while(father[r] != r)&#123;//找到根结点 r = father[r]; &#125; int i = x; int j; while(i != r)&#123;//循环修改这条路径上的根结点 j = father[i];//j记录元素i此时的父亲 father[i] = r;//将i的父亲改为根结点 i = j;//i记录为要“查询”的结点 &#125; return r;&#125; 经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$ 总结 并查集的思想很精妙，用一个数组表示了整片森林 优化的关键在于记录每棵树的结点数量，根据结点关系合并","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"https://www.niuwx.cn/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树（二）","slug":"树（二）","date":"2021-02-03T11:49:50.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"树（二）/","link":"","permalink":"https://www.niuwx.cn/%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"树的遍历上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。 以下是树的非递归遍历方法：","text":"树的遍历上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。 以下是树的非递归遍历方法： 偷个懒用一下C++写，头文件要加上 1#include&lt;stack&gt; 先序遍历123456789101112131415161718192021//先序遍历void PreorderNoneSecu(PTree T) &#123; cout&lt;&lt;&quot;先序非递归遍历&quot;&lt;&lt;endl; PTree t = T; stack&lt;PTree&gt; s; while(t || !s.empty())&#123; while(t)&#123; cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;;//拿到这个结点就直接打印 s.push(t); t = t-&gt;left; &#125; if(!s.empty())&#123; t = s.top(); s.pop(); t = t-&gt;right; &#125; &#125; cout &lt;&lt; endl;&#125; 中序遍历123456789101112131415161718192021//中序非递归遍历void InorderNoneSecu(PTree T) &#123; cout&lt;&lt;&quot;中序非递归遍历&quot;&lt;&lt;endl; PTree t = T; stack&lt;PTree&gt; s; while(t || !s.empty())&#123; while(t)&#123; s.push(t); t = t-&gt;left; &#125; if(!s.empty())&#123; t = s.top(); s.pop(); cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;;//遍历完左子树后再打印 t = t-&gt;right; &#125; &#125; cout &lt;&lt; endl;&#125; 后序遍历12345678910111213141516171819202122232425262728//后序非递归遍历void PostorderNoneSecu(PTree T) &#123; cout&lt;&lt;&quot;后序非递归遍历&quot;&lt;&lt;endl; PTree t = T; stack&lt;PTree&gt; s; stack&lt;PTree&gt; s2; while(t || !s.empty())&#123; while(t)&#123; s.push(t); s2.push(t); t = t-&gt;right; &#125; if(!s.empty())&#123; t = s.top(); s.pop(); t = t-&gt;left; &#125; &#125; while(!s2.empty())&#123; t = s2.top(); s2.pop(); cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"树（一）","slug":"树（一）","date":"2021-02-02T08:22:40.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"树（一）/","link":"","permalink":"https://www.niuwx.cn/%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。 对于非空树： 1.有且仅有一个称之为根的结点。 2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。","text":"树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。 对于非空树： 1.有且仅有一个称之为根的结点。 2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。 基本术语 结点的度（Degree）：结点的子树个数 树的度：树的所有结点最大的度 叶结点（Leaf）：度为0的结点 父结点（Parent）：有子树的结点是其子树的根结点的父结点 子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点 兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点 路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3…nk。路径所包含边的个数为路径的长度 祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点 子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙 结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一 树的深度（Depth）：树中所有结点中的最大层次 二叉树二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。 性质1.二叉树的第i层的最大节点数为 2.深度为k的二叉树最大结点数为 3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1 特殊的, 如果一个深度为 k 的二叉树，正好有 个结点，那么这棵树就被称为满二叉树。 如图所示： 如果一个二叉树，只有当第 i 层已经达到了的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为完全二叉树。 那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为$$[log_2(n)]+1$$ 如图所示： 二叉树的建立123456789#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct Tree&#123; int data; struct Tree *left; struct Tree *right;&#125; BiTree, *PTree; 12345678910111213141516171819202122232425262728293031323334353637//创造一个结点PTree CreatNode(int value) &#123; PTree p = (PTree)malloc(sizeof(BiTree)); p-&gt;data = value; p-&gt;left = p-&gt;right = NULL; return p;&#125;//插入结点且排序，不存在有相同值的结点PTree AddNode(int value, PTree p) &#123; if (p == NULL) &#123; return CreatNode(value); &#125; if (value == p-&gt;data) &#123; return p; &#125; if (value &lt; p-&gt;data) &#123; if (p-&gt;left == NULL) &#123; p-&gt;left = CreatNode(value); return p-&gt;left; &#125; else &#123; return AddNode(value, p-&gt;left); &#125; &#125; else &#123; if (p-&gt;right == NULL) &#123; p-&gt;right = CreatNode(value); return p-&gt;right; &#125; else &#123; return AddNode(value, p-&gt;right); &#125; &#125;&#125; 遍历二叉树递归遍历左子树、根节点、递归遍历右子树 先序遍历输出根节点，递归遍历左子树，在递归遍历右子树 1234567void Preorder(PTree p) &#123; if (p != NULL) &#123; printf(&quot;%d &quot;, p-&gt;data); Preorder(p-&gt;left); Preorder(p-&gt;right); &#125;&#125; 中序遍历递归遍历左子树，输出根节点，在递归遍历右子树 1234567void Midorder(PTree p) &#123; if (p != NULL) &#123; Midorder(p-&gt;left); printf(&quot;%d &quot;, p-&gt;data); Midorder(p-&gt;right); &#125;&#125; 后序遍历递归遍历左子树，再递归遍历右子树，输出根节点 1234567void Postorder(PTree p) &#123; if (p != NULL) &#123; Postorder(p-&gt;left); Postorder(p-&gt;right); printf(&quot;%d &quot;, p-&gt;data); &#125;&#125; 求二叉树的深度1234567891011int TreeHeight(PTree p) &#123; int l, r; if (p == NULL) &#123; return 0; &#125; else &#123; l = TreeHeight(p-&gt;left); r = TreeHeight(p-&gt;right); return (l &gt; r ? l : r) + 1; &#125;&#125; 12345678910111213141516171819202122232425int main(int argc, char const *argv[]) &#123;//测试 int value; PTree p = NULL; printf(&quot;Please enter 10 numbers:&quot;); for (int i = 0; i &lt; 10; ++i) &#123; scanf(&quot;%d&quot;, &amp;value); if (p == NULL) &#123; p = CreatNode(value); &#125; else &#123; AddNode(value, p); &#125; &#125; Preorder(p); printf(&quot;\\n&quot;); Midorder(p); printf(&quot;\\n&quot;); Postorder(p); printf(&quot;\\n&quot;); printf(&quot;The depth of the binary tree is：%d\\n&quot;, TreeHeight(p)); return 0;&#125;","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2021-01-31T15:38:33.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"栈和队列/","link":"","permalink":"https://www.niuwx.cn/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"引入栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。 顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。","text":"引入栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。 顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。 栈定义栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图 线性表有两种存储形式，顺序表储存和链表储存。 顺序栈12345678910111213#include&lt;stdlib.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0typedef int elem;typedef int Status;typedef struct Stack&#123; elem* base;//栈基 elem* top;//栈顶 int stacksize; //栈的容量&#125;Stack; 创建一个栈12345678Status CreatStack(Stack* s)&#123; s-&gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-&gt;base) return ERROR; s-&gt;top = s-&gt;base; s-&gt;stacksize = MAXSIZE; return OK;&#125; 入栈1234567891011121314Status PushStack(Stack* s, elem e)&#123; if(s-&gt;top - s-&gt;base &gt;= s-&gt;stacksize)&#123; s-&gt;base = (elem*)realloc(s-&gt;base, sizeof(elem) * MAXSIZE); if(!s-&gt;base) return ERROR; s-&gt;top = s-&gt;base + s-&gt;stacksize; s-&gt;stacksize +=MAXSIZE; &#125; *(s-&gt;top) = e; s-&gt;top++; return OK;&#125; 出栈123456Status PopStack(Stack*s,elem *e)&#123; if(s-&gt;top == s-&gt;base) return ERROR; *e = *--(s-&gt;top); return OK;&#125; 清空1234Status CleanStack(Stack* s)&#123; s-&gt;top = s-&gt;base; return OK;&#125; 销毁1234567Status DestroyStack(Stack* s)&#123; free(s-&gt;base); s-&gt;top = s-&gt;base = NULL; s-&gt;stacksize = 0; return OK;&#125; 获取当前容量123int GetSize(Stack* s)&#123; return s-&gt;stacksize;&#125; 链表栈123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define OK 1#define ERROR 0typedef int elem;typedef int Status;typedef struct Node//定义链表结构&#123; elem data;//数据域 struct Node* next;//指针域&#125;Node, * LNode;typedef struct Stack&#123; LNode top; LNode base;&#125;Stack,*Pstack; 创建一个栈12345678910Pstack CreatStack()&#123; Pstack stack = (Pstack)malloc(sizeof(Stack)); if(stack == NULL)&#123; return NULL; &#125; stack-&gt;top = stack-&gt;base = NULL; return stack;&#125; 入栈1234567891011Status PushStack(Pstack *stack, elem e)&#123; Node* p = (LNode)malloc(sizeof(Node)); if(p == NULL)&#123; return ERROR; &#125; p-&gt;data = e; p-&gt;next = (*stack)-&gt;top; (*stack)-&gt;top = p; return OK;&#125; 出栈123456789101112Status PopStack(Pstack *stack)&#123; Node* p = (*stack)-&gt;top; if(p == (*stack)-&gt;base)&#123; printf(&quot;栈已空&quot;); return ERROR; &#125; (*stack)-&gt;top = p-&gt;next; printf(&quot;%d &quot;,p-&gt;data); free(p); return OK;&#125; 判断是否为空123Status IsEmptyStack(Pstack stack)&#123; return (stack-&gt;top == stack-&gt;base);&#125; 清空123456789Status CleanStack(Pstack *stack)&#123; Node*p = (*stack)-&gt;top; while(p)&#123; (*stack)-&gt;top = p-&gt;next; free(p); p = (*stack)-&gt;top; &#125; return OK;&#125; 销毁1234567Status DestroyStack(Pstack *stack)&#123; CleanStack(stack); free(*stack); return OK;&#125; 123456789101112131415161718192021222324252627282930void test()&#123;//测试 Pstack stack = CreatStack(); printf(&quot;%d\\n&quot;, IsEmptyStack(stack)); for (int i = 0; i &lt; 10; ++i)&#123; PushStack(&amp;stack, i); &#125; printf(&quot;%d\\n&quot;, IsEmptyStack(stack)); /*出栈*/ // for (int i = 0; i &lt; 10; ++i)&#123; // PopStack(&amp;stack); // &#125; // printf(&quot;%\\n&quot;); // printf(&quot;%d\\n&quot;, IsEmptyStack(stack)); /*清空*/ CleanStack(&amp;stack); printf(&quot;%d\\n&quot;, IsEmptyStack(stack)); printf(&quot;%p\\n&quot;,stack); DestroyStack(&amp;stack); printf(&quot;%d\\n&quot;, IsEmptyStack(stack)); printf(&quot;%p\\n&quot;,stack);&#125; 栈与递归递归：函数自己调用自己 函数定义是递归的——斐波那契数列 数据结构是递归的——单链表、树 问题解法是递归的——汉诺塔、 函数的调用函数被调用之前， 系统需要将实参以及返回地址传递给被调用的函数进行保存 将被调用的函数的局部变量分配到储存区 将控制转移到被调用的函数的入口 从被调用函数返回到调用函数之前， 保存被调用函数的计算结果 释放被调用函数中的数据区 依照被调用函数的保存的返回地址将控制转移至此 队列定义队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示 链队列12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define OK 1#define ERROR 0typedef int elem;typedef int Status;typedef struct QNode &#123; elem data; //数据域 struct QNode*next; //指针域&#125; QNode, *PNode;typedef struct &#123; PNode front; //队头指针 PNode rear; //队尾指针&#125; LinkQueue; 创建一个队列1234567891011Status CreatQueue(LinkQueue *q) &#123; q-&gt;front = q-&gt;rear = (PNode)malloc(sizeof(QNode)); if (q-&gt;front == NULL) &#123; return ERROR; &#125; q-&gt;front-&gt;next = NULL; return OK;&#125; 入队123456789101112Status PushQueue(LinkQueue *q, elem e) &#123; QNode *p = (PNode)malloc(sizeof(QNode)); if (p == NULL) &#123; return ERROR; &#125; p-&gt;data = e; p-&gt;next = NULL; q-&gt;rear-&gt;next = p; q-&gt;rear = p; return OK;&#125; 出队123456789101112Status PopQueue(LinkQueue *q) &#123; if (q-&gt;front == q-&gt;rear) &#123; return ERROR; &#125; QNode* p = q-&gt;front-&gt;next; printf(&quot;%d &quot;, p-&gt;data); q-&gt;front-&gt;next = p-&gt;next; if (q-&gt;rear == p) q-&gt;rear = q-&gt;front; return OK;&#125; 销毁12345678Status DestroyQueue(LinkQueue *q) &#123; while (q-&gt;front) &#123; q-&gt;rear = q-&gt;front-&gt;next; free(q-&gt;front); q-&gt;front = q-&gt;rear; &#125; return OK;&#125;","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"单链表","slug":"单链表","date":"2021-01-30T09:47:35.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"单链表/","link":"","permalink":"https://www.niuwx.cn/%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。","text":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。 每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。 在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。 头指针和头节点基本概念头指针通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。 头节点在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。 [注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。 空链表 单链表 引入头结点的优势链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。 优势1：第一个位置的插入删除特别方便若使用头结点，则第1个位置的插入和删除都是对p—&gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为： 插入操作如下 p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—&gt;next = p—&gt;next; 让p—&gt;next指向s，即p—&gt;next = s; 删除操作如下 p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—&gt;next； 让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next； 释放q的空间，即free(q); 若没有头结点，在第1个位置插入或删除时，需要动头指针。 插入操作如下 判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—&gt;next = p—&gt;next; 让p—&gt;next指向s，即p—&gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。 删除操作如下 判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—&gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—&gt;next； 让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next； 释放q的空间，即free(q); return PtrL 优势2：统一空表和非空表的处理若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。 若不使用头结点，当表非空时，头指针指向第1个结点的地址，即LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。 链表的建立有头结点链表的建立123456789101112#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define OK 1#define ERROR 0typedef int elem;typedef int Status;typedef struct LNode&#123; elem data; //数据域 struct LNode* next; //指针域&#125;Node, *List; 123456789101112List HeadCreatList(int n)&#123;//带头结点_头插法 Node *s; List head = (List)malloc(sizeof(Node));//生成头结点 head-&gt;next = NULL; for (int i = 0; i &lt; n; i++)&#123; s = (List)malloc(sizeof(Node)); s-&gt;data = i; s-&gt;next = head-&gt;next; head-&gt;next = s;//头结点的指针域next指向s结点，使得s成为结点 &#125; return head;&#125; 123456789101112131415161718List TailCreatList(int n)&#123;//带头结点_尾插法 Node *s, *r; List head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; r = head; for (int i = 0; i &lt; n; i++)&#123; s = (List)malloc(sizeof(Node)); s-&gt;data = i; r-&gt;next = s; r = s; &#125; if(r-&gt;next != NULL)&#123; r-&gt;next = NULL; &#125; return head;&#125; 下面这个是建立头结点与建立链表分离 123456List CreatHNode()&#123;//建立头结点 Node *s, *r; List head = (List)malloc(sizeof(Node)); head-&gt;next = NULL; return head;&#125; 12345678910Status HeadList(List head, int n)&#123;//头插法 Node *s; for (int i = 0; i &lt; n; i++)&#123; s = (List)malloc(sizeof(Node)); s-&gt;data = i; s-&gt;next = head-&gt;next; head-&gt;next = s;//头结点的指针域next指向s结点，使得s成为结点 &#125; return OK;&#125; 123456789101112131415Status TailList(List head, int n)&#123;//尾插法 Node *s, *r; r = head; for (int i = 0; i &lt; n; i++)&#123; s = (List)malloc(sizeof(Node)); s-&gt;data = i; r-&gt;next = s; r = s; &#125; if(r-&gt;next != NULL)&#123; r-&gt;next = NULL; &#125; return OK;&#125; 为了方便测试，先写出遍历并打印链表的函数 12345678910Status PrintList(List head)&#123;//打印链表数据 Node *t = head-&gt;next; while (t != NULL)&#123; printf(&quot;%d &quot;,t-&gt;data); t = t-&gt;next; &#125; printf(&quot;\\n&quot;); return OK;&#125; 123456789101112void test()&#123;//测试 List head; //head = HeadCreatList(10); head = TailCreatList(10); //head = CreatHNode(); //HeadList(head, 10); //TailList(head, 10); PrintList(head); system(&quot;pause&quot;); return;&#125; 无头结点链表的建立123456789101112131415161718List HeadCreatList(int n)&#123;//头插法 List head = NULL; Node *p; while(n--)&#123; p = (List)malloc(sizeof(Node)); p-&gt;data = n; if(head == NULL)&#123; p-&gt;next = NULL; head = p; &#125; else&#123; p-&gt;next = head; head = p; &#125; &#125; return head;&#125; 1234567891011121314151617List TailCreatList(int n)&#123;//尾插法 List head = NULL; Node *p, *q; while(n--)&#123; p = (List)malloc(sizeof(Node)); p-&gt;data = n; if(head == NULL)&#123; head = p; &#125; else&#123; q-&gt;next = p; &#125; p-&gt;next = NULL; q = p; &#125; return head;&#125; 为了测试，先写出打印链表的函数 123456789101112Status PrintList(List head)&#123;//打印链表元素 if(head == NULL)&#123; return ERROR; &#125; Node *t = head; while(t != NULL)&#123; printf(&quot;%d&quot;, t-&gt;data); t = t-&gt;next; &#125; printf(&quot;%d&quot;); return OK;&#125; 1234567void test()&#123;//测试 List head; //head = HeadCreatList(10); head = TailCreatList(10); PrintList(head); return ;&#125; 链表的各个功能的实现（有头结点）上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行 链表元素的添加12345678//链表添加元素（插头）Status HeadInsertList(List head,Node a)&#123; Node *p = (List)malloc(sizeof(Node)); p-&gt;data = a.data; p-&gt;next = head-&gt;next; head-&gt;next = p; return OK;&#125; 1234567891011121314//链表添加元素（插尾）Status TailInsertList(List head,Node a)&#123; Node *p, *t, *s; t = head-&gt;next; p = (List)malloc(sizeof(Node)); p-&gt;data = a.data; while(t!= NULL)&#123; s = t; t = t-&gt;next; &#125; s-&gt;next = p; p-&gt;next = NULL; return OK;&#125; 12345678910111213141516void test()&#123;//测试 List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); //HeadInsertList(head, a); TailInsertList(head, a); PrintList(head); system(&quot;pause&quot;); return;&#125; 链表元素的插入12345678910111213141516171819202122//链表的插入（插在之前）Status InsertIndexFront(List head,int i)&#123; Node *p, *q, *r; int j = 0; p = head; while(p &amp;&amp; j &lt; i)&#123; r = p; p = p-&gt;next; j++; &#125; if(!p || j&gt;i)&#123; return ERROR; &#125; q = (List)malloc(sizeof(Node)); scanf(&quot;%d&quot;,&amp;q-&gt;data); q-&gt;next = p; r-&gt;next = q; return OK;&#125; 123456789101112131415161718192021//链表的插入（插在之后）Status InsertIndexBack(List head,int i)&#123; Node *p,*q; int j = 0; p = head; while(p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; j++; &#125; if(!p || j &gt; i)&#123; return ERROR; &#125; q = (List)malloc(sizeof(Node)); scanf(&quot;%d&quot;,&amp;q-&gt;data); q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125; 1234567891011121314oid test()&#123;//测试 List head; head = HeadCreatList(10); PrintList(head); InsertIndexFront(head,2); //InsertIndexBack(head,2); PrintList(head); system(&quot;pause&quot;); return;&#125; 链表元素的查找123456789101112131415//链表元素的查找elem GetElem(List head, int index)&#123;//按序号查找 int j; Node* p; p = head-&gt;next; //p指向第一个数据结点 j = 1; //j为计数器 while (p &amp;&amp; j &lt; index )&#123; //顺着链表向后扫描，直到p指向第i个元素或p为空 p=p-&gt;next; //p指向下一个结点 j++; //计数器j相应加1 &#125; if (!p || j &gt; index) return -1; //i值不合法i＞n或i&lt;=0 return p-&gt;data;//返回第i个结点的数据域&#125; 12345678910111213141516elem GetIndex(List head, int e) &#123;//按值查找 //在带头结点的单链表L中查找值为e的元素 Node* p; int index = 0; p = head-&gt;next; while (p &amp;&amp; p-&gt;data!=e)&#123; //顺链域向后扫描，直到p为空或p所指结点的数据域等于e p=p-&gt;next; //p指向下一个结点 ++index; &#125; if(!p) return -1; //查找失败p为NULL return index;&#125; 1234567891011121314void test()&#123; List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); printf(&quot;%d\\n&quot;,GetElem(head,6)); printf(&quot;%d\\n&quot;,GetIndex(head,6)); system(&quot;pause&quot;); return;&#125; 链表元素的删除1234567891011121314151617Status DeleteList(List head, int index) &#123;//单链表的删除 //在带头结点的单链表L中，删除第i个位置 Node *p, *q; int j; p = head; j = 0; while((p-&gt;next)&amp;&amp;(j &lt; index - 1)) &#123;//查找第i-1个结点，p指向该结点 p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||(j &gt; index - 1))//当i&gt;n或i&lt;1时，删除位置不合理 return ERROR; q = p-&gt;next; //临时保存被删结点的地址以备释放空间 p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 free(q); //释放被删除结点的空间 return OK;&#125; 123456789101112131415void test()&#123;//测试 List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); DeleteList(head,4); PrintList(head); system(&quot;pause&quot;); return;&#125; 链表元素的修改123456789101112131415//链表元素的修改Status ReverseElem(List head, int index,int e)&#123; int j; Node* p; p = head-&gt;next; //p指向第一个数据结点 j = 1; //j为计数器 while (p &amp;&amp; j &lt; index )&#123; //顺着链表向后扫描，直到p指向第i个元素或p为空 p=p-&gt;next; //p指向下一个结点 j++; //计数器j相应加1 &#125; if (!p || j &gt; index) return ERROR; //i值不合法i＞n或i&lt;=0 p-&gt;data = e; return OK;//返回第i个结点的数据域&#125; 123456789101112131415void test()&#123;//测试 List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); ReverseElem(head,4,999); PrintList(head); system(&quot;pause&quot;); return;&#125; 链表元素的清空12345678910111213141516//清空链表Status ClearList(List head) &#123; Node*p,*q; if(head == NULL) return ERROR; p = head-&gt;next; while(p!=NULL) &#123; q=p-&gt;next; free(p); p=q; &#125; head-&gt;next=NULL; return OK; &#125; 链表元素的排序1234567891011121314151617181920212223Status SwapElem(int *i, int *j)&#123;//交换数据 int temp = *i; *i = *j; *j = temp; return OK;&#125;void SortList(List head)&#123;//冒泡排序 Node* p = NULL; Node* q = NULL; Node* t = NULL; if(head-&gt;next == NULL)&#123; return ; &#125; for ( p = head-&gt;next; p != NULL; p = p-&gt;next)&#123; for ( q = head-&gt;next; q-&gt;next != NULL; q = q-&gt;next)&#123; if(q-&gt;data &gt; q-&gt;next-&gt;data)&#123; SwapElem(&amp;q-&gt;data, &amp;q-&gt;next-&gt;data); &#125; &#125; &#125;&#125; 无头结点链表的功能实现就不在此赘述，所有源码都在Github","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"顺序表","slug":"顺序表","date":"2021-01-29T09:47:35.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"顺序表/","link":"","permalink":"https://www.niuwx.cn/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"概念具有 一对一 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表） 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0typedef int Status;typedef int elem;typedef struct Sqlist&#123; elem *e;//存储空间的及地址 int length;//长度&#125;Sqlist;","text":"概念具有 一对一 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表） 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define MAXSIZE 100#define OK 1#define ERROR 0typedef int Status;typedef int elem;typedef struct Sqlist&#123; elem *e;//存储空间的及地址 int length;//长度&#125;Sqlist; 功能的实现顺序表的初始化1234567891011121314151617//数组的初始化Status InitArray(Sqlist *L)&#123; if(L-&gt;e) &#123;//判断指针是否为空 free(L-&gt;e); L-&gt;e = NULL; &#125; L-&gt;e = (elem*)malloc(sizeof(int) * MAXSIZE);//申请capacity大小的空间 if(L-&gt;e == NULL)&#123; printf(&quot;内存分配失败!\\n&quot;);//判断内存分配是否成功 exit(0); &#125; L-&gt;length = 0; return OK;&#125; 元素的添加1234567891011121314//添加元素Status PushBackArray(Sqlist *L,elem value)&#123; if(L-&gt;e == NULL)&#123; printf(&quot;请初始化顺序表\\n&quot;); return ERROR; &#125; if(L-&gt;length == MAXSIZE) &#123; return ERROR; &#125; L-&gt;e[L-&gt;length] = value; ++L-&gt;length; return OK;&#125; 元素的插入123456789101112131415//插入Status InsertArray(Sqlist *L,int index,elem value)&#123; if(index &gt; L-&gt;length +1 || index &lt; 1)&#123; return ERROR; &#125; for (int i = L-&gt;length; i &gt;= index; i--) &#123; L-&gt;e[i] = L-&gt;e[i - 1]; &#125; L-&gt;e[index] = value; ++L-&gt;length; return OK;&#125; 元素的查找1234//根据位置查找elem FindByIndex(Sqlist* L,int index)&#123; return L-&gt;e[index];&#125; 123456789//根据值查找Status FindByValue(Sqlist* L,elem value)&#123; for (int i = 0; i &lt; L-&gt;length; i++)&#123; if(L-&gt;e[i] == value)&#123; return i; &#125; &#125; return -1;&#125; 元素的删除12345678910111213//根据值删除Status RemoveByValue(Sqlist* L,elem value)&#123; for (int i = 0; i &lt; L-&gt;length; i++)&#123; if(L-&gt;e[i] == value)&#123; for (; i &lt; L-&gt;length; i++) &#123; L-&gt;e[i - 1] = L-&gt;e[i]; &#125; --L-&gt;length; return OK; &#125; &#125;&#125; 12345678910111213//根据位置删除Status RemoveByIndex(Sqlist* L,int index)&#123; if (index &gt; L-&gt;length + 1 || index &lt; 1) &#123; return ERROR; &#125; for (int i = index; i &lt; L-&gt;length; i++) &#123; L-&gt;e[i - 1] = L-&gt;e[i]; &#125; --L-&gt;length; return OK;&#125; 元素的清空1234567891011//清空Status CleanArray(Sqlist *L)&#123; if(L-&gt;e == NULL) &#123; printf(&quot;未初始化\\n&quot;); return ERROR; &#125; L-&gt;length = 0; return OK;&#125; 线性表的销毁1234567891011//销毁Status FreeArray(Sqlist* L)&#123; if(L-&gt;e != NULL)&#123; free(L-&gt;e); L-&gt;e = NULL; &#125; L-&gt;length = 0; return OK;&#125; 获取当前长度12345//长度int GetLength(Sqlist* L)&#123; if(L-&gt;e == NULL) return -1; return L-&gt;length;&#125; 判断是否为空12345//判断是否为空Status IsEmptyArray(Sqlist *L)&#123; return L-&gt;length = 0;&#125; 顺序表的合并1234567891011121314151617//合并Status CombineArray(Sqlist *L1,Sqlist *L2)&#123; if (L1-&gt;length + L2-&gt;length &gt; MAXSIZE) &#123; printf(&quot;空间不足，合并失败\\n&quot;); return ERROR; &#125; for (int i = 0; i &lt; L2-&gt;length; i++) &#123; L1-&gt;e[L1-&gt;length + i] = L2-&gt;e[i]; &#125; L1-&gt;length +=L2-&gt;length; free(L2-&gt;e); L2-&gt;length = 0; return OK;&#125; 顺序表的打印1234567//打印void PrintArray(Sqlist* L)&#123; for (int i = 0; i &lt; L-&gt;length; i++)&#123; printf(&quot;%d &quot;,L-&gt;e[i]); &#125; printf(&quot;\\n&quot;);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void test()&#123;//测试 Sqlist L,L2; /******************************/ /********初始化及添加元素********/ /******************************/ InitArray(&amp;L);//初始化顺序表 InitArray(&amp;L2); //srand(time(NULL)); for(int i = 0; i &lt; 10; i++)&#123;//赋值 PushBackArray(&amp;L,i); PushBackArray(&amp;L2,i); &#125; printf(&quot;初始化...\\n&quot;); PrintArray(&amp;L);//打印 printf(&quot;%d\\n&quot;, GetLength(&amp;L));//获取当前长度 /******************************/ /************插入元素***********/ /******************************/ InsertArray(&amp;L,5,100);//插入元素 printf(&quot;插入元素...\\n&quot;); PrintArray(&amp;L);//打印 printf(&quot;%d\\n&quot;, GetLength(&amp;L));//获取当前长度 /******************************/ /************查找元素***********/ /******************************/ printf(&quot;查找元素...\\n&quot;); printf(&quot;%d &quot;,FindByIndex(&amp;L,10));//根据位置查找 printf(&quot;%d &quot;,FindByValue(&amp;L,4));//根据值查找 /******************************/ /************删除元素***********/ /******************************/ RemoveByIndex(&amp;L,3);//根据位置删除 RemoveByValue(&amp;L,9);//根据值删除 printf(&quot;删除元素...\\n&quot;); PrintArray(&amp;L);//打印 printf(&quot;%d\\n&quot;, GetLength(&amp;L));//获取当前长度 /******************************/ /***********合并顺序表**********/ /******************************/ CombineArray(&amp;L,&amp;L2);//合并 printf(&quot;合并顺序表...\\n&quot;); PrintArray(&amp;L);//打印 printf(&quot;%d\\n&quot;, GetLength(&amp;L));//获取当前长度 /******************************/ /***********清空顺序表**********/ /******************************/ CleanArray(&amp;L);//清空 printf(&quot;清空顺序表...\\n&quot;); PrintArray(&amp;L);//打印 printf(&quot;%d\\n&quot;, GetLength(&amp;L));//获取当前长度 /******************************/ /***********销毁顺序表**********/ /******************************/ FreeArray(&amp;L);//销毁 printf(&quot;销毁顺序表...\\n&quot;); printf(&quot;%d&quot;,PushBackArray(&amp;L,1));&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"顺序表","slug":"顺序表","permalink":"https://www.niuwx.cn/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]},{"title":"数据结构概括","slug":"基础知识","date":"2021-01-29T08:47:35.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"基础知识/","link":"","permalink":"https://www.niuwx.cn/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"数据所有能够输入到计算机中的去的描述客观事物的符号 数据元素数据的基本单位，也称结点或记录 数据结构相互之间存在一种或多种特定关系的数据元素的集合","text":"数据所有能够输入到计算机中的去的描述客观事物的符号 数据元素数据的基本单位，也称结点或记录 数据结构相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构和存储结构逻辑结构数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。 1.集合数据元素间除同属于一个集合外，无其他关系集合中的元素是离散的、无序的、相互之间没有关系的 2.线性结构一个对一个 线性表 栈 队列线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束 3.树形结构一个对多个树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。 树 4.图形结构图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。 存储结构存储结构是数据元素及其关系在计算机中的存储方式。 1.顺序结构顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。 2.链式结构链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。 3.散列机构4.索引结构算法复杂性时间复杂度程序运行所需的时间 常数阶 O(1) O(n) O(n²) O(log(n))-二分查找 O(nlogn)-快排递归时间复杂度O(T * depth) T是每一次递归的时间复杂度最好最坏情况时间复杂度平均时间复杂度空间复杂度程序运行所需的空间 主要分为两部分： 固定部分：指令空间、数据空间（静态空间） 可变空间：动态分配的空间 S(n) = O(f(n))","categories":[{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"}]},{"title":"Hello","slug":"Hello","date":"2021-01-28T04:01:37.000Z","updated":"2021-07-01T04:38:52.348Z","comments":true,"path":"Hello/","link":"","permalink":"https://www.niuwx.cn/Hello/","excerpt":"","text":"Hello World!","categories":[],"tags":[],"author":"fadai"}],"categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/categories/Golang/"},{"name":"数据结构","slug":"datastruct","permalink":"https://www.niuwx.cn/categories/datastruct/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"拓展欧几里得","slug":"拓展欧几里得","permalink":"https://www.niuwx.cn/tags/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"算法笔记","slug":"算法笔记","permalink":"https://www.niuwx.cn/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://www.niuwx.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"图论","slug":"图论","permalink":"https://www.niuwx.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Golang","slug":"Golang","permalink":"https://www.niuwx.cn/tags/Golang/"},{"name":"Go","slug":"Go","permalink":"https://www.niuwx.cn/tags/Go/"},{"name":"并发","slug":"并发","permalink":"https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"goroutine","slug":"goroutine","permalink":"https://www.niuwx.cn/tags/goroutine/"},{"name":"channel","slug":"channel","permalink":"https://www.niuwx.cn/tags/channel/"},{"name":"select","slug":"select","permalink":"https://www.niuwx.cn/tags/select/"},{"name":"原子操作","slug":"原子操作","permalink":"https://www.niuwx.cn/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"},{"name":"并发安全和锁","slug":"并发安全和锁","permalink":"https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/"},{"name":"接口","slug":"接口","permalink":"https://www.niuwx.cn/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"结构体","slug":"结构体","permalink":"https://www.niuwx.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"指针","slug":"指针","permalink":"https://www.niuwx.cn/tags/%E6%8C%87%E9%92%88/"},{"name":"高精度计算","slug":"高精度计算","permalink":"https://www.niuwx.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"函数","slug":"函数","permalink":"https://www.niuwx.cn/tags/%E5%87%BD%E6%95%B0/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"整型","slug":"整型","permalink":"https://www.niuwx.cn/tags/%E6%95%B4%E5%9E%8B/"},{"name":"浮点型","slug":"浮点型","permalink":"https://www.niuwx.cn/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"},{"name":"布尔型","slug":"布尔型","permalink":"https://www.niuwx.cn/tags/%E5%B8%83%E5%B0%94%E5%9E%8B/"},{"name":"字符串","slug":"字符串","permalink":"https://www.niuwx.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"切片","slug":"切片","permalink":"https://www.niuwx.cn/tags/%E5%88%87%E7%89%87/"},{"name":"变量与常量","slug":"变量与常量","permalink":"https://www.niuwx.cn/tags/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"},{"name":"C\\C++","slug":"C-C","permalink":"https://www.niuwx.cn/tags/C-C/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.niuwx.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"算法","slug":"算法","permalink":"https://www.niuwx.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"https://www.niuwx.cn/tags/STL/"},{"name":"C++","slug":"C","permalink":"https://www.niuwx.cn/tags/C/"},{"name":"高级数据结构","slug":"高级数据结构","permalink":"https://www.niuwx.cn/tags/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"顺序表","slug":"顺序表","permalink":"https://www.niuwx.cn/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"}]}